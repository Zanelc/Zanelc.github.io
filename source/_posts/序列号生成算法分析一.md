---
title: 序列号生成算法分析一
categories:
  - 使用Ollydbg从零开始Cracking
tags:
  - xdbg基础使用
  - 序列号算法分析
  - 菜鸡逆向
abbrlink: 77d1b2e4
date: 2023-08-13 19:46:58
index_img: https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/title.png
---

这里分析的crackme与之前的不同之处在于序列号时基于名称变化的，也就是序列号生成具有一定的算法。

<!--more-->

<p class="note note-danger">其实一直都想使用新版x32dbg来取代OD，OD毕竟没人维护了(主要还是界面太古老，在2K显示器上面看着很不舒服)，可是想着又是看的OD的入门教程，就一直没有替换为xdbg，终于今天在经历数次OD加载程序崩溃、转圈、加载不出来后，决定弃用OD采用xdbg来进行逆向学习，尽管xdbg还有很多不完善的地方。在本文中，xdbg对内存下断点会出现各种各样的问题，据说是因为内存对齐的原因，具体不深究，目前流行的解决方法是改为硬件断点，除非遇到xdbg无法解决的问题，不然将会一直采用xdbg进行内容更新。</p>

## CureHead'a

### 程序分析

**注：序列号为数字类型(不要问为什么，就是这样设计的。)**

**x32dbg** 加载程序，查看API窗口，发现使用 **GetDlgItemeTextA** 来获取输入。

![API窗口](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814005631058.png)

在该API函数处下断点，运行程序，输入序列号。

![输入序列号](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814005710615.png)

继续 **执行到返回**，输入的 **Name** 存储在缓冲区 **0040218E** 处，**Serial** 存储在缓冲区 **40217E** 处。

![字符串缓冲区](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814010121513.png)

对两处分别下硬件访问断点，看看程序是如何处理输入的名称和序列号，程序访问 **0040218E**断在该处。

![中断](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814225758008.png)

分析该处指令，程序进行逐字符判断，当字符不为0时，将小写字符转化为大写字符，**sub al，0x20** 实现转换，若字符为大写，则继续判断下一个字符，字符不属于字母则直接弹出错误窗口。

![小写转大写](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814230645433.png)

转换为大写后，进行如下算法，**将每个字符的十六进制值进行相加，然后与0x5678进行异或运算，将值存储在EAX中**，至此，对名称处理完毕。

![算法分析](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814231132330.png)

继续运行程序，断在访问序列号处。

![中断](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234111572.png)

分析该处指令，程序对输入的序列号逐字符处理，**如果字符不等于0，将当前字符减去0x30，然后再乘10，最后累加到寄存器EDI中** ，对于输入的数字类型的序列号， **相当于把十六进制字符串转化为10进制字符串 ，最后将结果与0x1234异或运算**。

![序列号算法](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234306504.png)

![十进制数字](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234534853.png)



对算法分析完毕后，继续运行程序，此时，两次算法过后的字符串分别存储在 **EAX和EBX** 中，对值进行比较，若相同，弹窗成功！

![比较](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234739029.png)

明显二者不相同，这里手动把 **ZF** 标志位置1，继续执行，弹窗成功。

![弹窗成功](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814235058906.png)

### 注册机编写

#### 原理概述

通过对上面程序的逐过程分析，我们了解到程序的大致原理：输入名称和序列号，程序会对名称和序列号进行一定的算法，然后比较，二者相同则弹窗成功。

**对名称处理：将输入名称中的小写字符全部转为大写字符，然后逐个字符相加，结果与0x5678异或**

**对序列号处理：将输入序列号的字符转化为10进制数字，结果与0x1234异或**

**根据异或特性，我们只需将对名称处理后的序列号与0x1234进行异或即可得到10进制序列号。**

#### **注册机**

```C
#include<stdio.h>
#include<ctype.h>
int main(void)
{
	char name[20];
	while (1)
	{
		printf("Please input your name: ");
		scanf_s("%s", name, sizeof(name));
		int i = 0;
		int res = 0;
		while (name[i] != '\0')
		{
			if (islower(name[i]))
				name[i] = toupper(name[i]);
			res += name[i];
			i++;
		}
		res = res ^ 0x5678 ^ 0x1234;
		printf("Your Serials is %d.\n", res);
	}
	return 0;
}
```

运行程序，任意输入名称，获取序列号，弹窗成功。

![输入名称与序列号](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230815003026765.png)

![破解成功](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230815003047382.png)
