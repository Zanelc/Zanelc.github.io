---
title: 序列号生成算法分析一
categories:
  - [使用Ollydbg从零开始Cracking,xdbg使用]
tags:
  - xdbg基础使用
  - 序列号算法分析
  - 菜鸡逆向
abbrlink: 77d1b2e4
date: 2023-08-13 19:46:58
index_img: https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/title.png
---

这里分析的crackme与之前的不同之处在于序列号时基于名称变化的，也就是序列号生成具有一定的算法。

<!--more-->

<p class="note note-danger">其实一直都想使用新版x32dbg来取代OD，OD毕竟没人维护了(主要还是界面太古老，在2K显示器上面看着很不舒服)，可是想着又是看的OD的入门教程，就一直没有替换为xdbg，终于今天在经历数次OD加载程序崩溃、转圈、加载不出来后，决定弃用OD采用xdbg来进行逆向学习，尽管xdbg还有很多不完善的地方。在本文中，xdbg对内存下断点会出现各种各样的问题，据说是因为内存对齐的原因，具体不深究，目前流行的解决方法是改为硬件断点，除非遇到xdbg无法解决的问题，不然将会一直采用xdbg进行内容更新。</p>

## CureHead'a

### 程序分析

**注：序列号为数字类型(不要问为什么，就是这样设计的。)**

**x32dbg** 加载程序，查看API窗口，发现使用 **GetDlgItemeTextA** 来获取输入。

![API窗口](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814005631058.png)

在该API函数处下断点，运行程序，输入序列号。

![输入序列号](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814005710615.png)

继续 **执行到返回**，输入的 **Name** 存储在缓冲区 **0040218E** 处，**Serial** 存储在缓冲区 **40217E** 处。

![字符串缓冲区](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814010121513.png)

对两处分别下硬件访问断点，看看程序是如何处理输入的名称和序列号，程序访问 **0040218E**断在该处。

![中断](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814225758008.png)

分析该处指令，程序进行逐字符判断，当字符不为0时，将小写字符转化为大写字符，**sub al，0x20** 实现转换，若字符为大写，则继续判断下一个字符，字符不属于字母则直接弹出错误窗口。

![小写转大写](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814230645433.png)

转换为大写后，进行如下算法，**将每个字符的十六进制值进行相加，然后与0x5678进行异或运算，将值存储在EAX中**，至此，对名称处理完毕。

![算法分析](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814231132330.png)

继续运行程序，断在访问序列号处。

![中断](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234111572.png)

分析该处指令，程序对输入的序列号逐字符处理，**如果字符不等于0，将当前字符减去0x30，然后再乘10，最后累加到寄存器EDI中** ，对于输入的数字类型的序列号， **相当于把十六进制字符串转化为10进制字符串 ，最后将结果与0x1234异或运算**。

![序列号算法](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234306504.png)

![十进制数字](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234534853.png)



对算法分析完毕后，继续运行程序，此时，两次算法过后的字符串分别存储在 **EAX和EBX** 中，对值进行比较，若相同，弹窗成功！

![比较](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234739029.png)

明显二者不相同，这里手动把 **ZF** 标志位置1，继续执行，弹窗成功。

![弹窗成功](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814235058906.png)

### 注册机编写

#### 原理概述

通过对上面程序的逐过程分析，我们了解到程序的大致原理：输入名称和序列号，程序会对名称和序列号进行一定的算法，然后比较，二者相同则弹窗成功。

**对名称处理：将输入名称中的小写字符全部转为大写字符，然后逐个字符相加，结果与0x5678异或**

**对序列号处理：将输入序列号的字符转化为10进制数字，结果与0x1234异或**

**根据异或特性，我们只需将对名称处理后的序列号与0x1234进行异或即可得到10进制序列号。**

#### **注册机**

```C
#include<stdio.h>
#include<ctype.h>
int main(void)
{
	char name[20];
	while (1)
	{
		printf("Please input your name: ");
		scanf_s("%s", name, sizeof(name));
		int i = 0;
		int res = 0;
		while (name[i] != '\0')
		{
			if (islower(name[i]))
				name[i] = toupper(name[i]);
			res += name[i];
			i++;
		}
		res = res ^ 0x5678 ^ 0x1234;
		printf("Your Serials is %d.\n", res);
	}
	return 0;
}
```

运行程序，任意输入名称，获取序列号，弹窗成功。

![输入名称与序列号](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230815003026765.png)

![破解成功](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230815003047382.png)

## Splish

### 程序分析

加载程序后，查看 **API窗口** ，发现是根据 **GetwindowTextA** 来获取输入，对该函数下断点后运行程序。

![API窗口](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816011115839.png)

![输入](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816011220089.png)

输入 **Name** 保存在 **403236** 处，**Serial** 保存在 **403242** 处。

![中断](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816011409695.png)

继续单步运行程序，发现两次调用 **GetWindowTextA** 函数后，返回值( **输入字符串长度** )被存储在 **403467** 和 **403463** 处。

![image-20230816011633202](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816011633202.png)

接下来分析对 **输入Name** 的处理，**ESI** 存储原始字符串地址，**EDI** 存储算法处理后的字符串地址，逐个字符依次处理。

![Name算法分析](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816012004992.png)

> cdq指令用于将一个有符号的32位数扩展为64位数。具体来说，它将EAX寄存器中的32位有符号数扩展为EDX:EAX寄存器对中的64位有符号数。
>
> idiv是汇编语言中的除法指令，用于执行有符号除法操作。
>
> - 商：商的结果存储在EAX寄存器中。
> - 余数：余数的结果存储在EDX寄存器中

此处 **cdq** 指令用于将 **EDX** 置0，然后进行有符号位除法，此处对字符除以 **0xA** 后，商存储在 **EAX** 中，余数存储在 **EDX** 中， **将余数与EBX的值进行异或运算后加2**，然后将得到的 **EDX的低位字节dl值** 与 **0xA** 进行比较，如果大于，则 **DL-0xA** ，最后将 **DL** 的值存储在指定地点，依次进行下一个值得比较。

使用 **IDA** 对代码进行反编译后，对 **name** 执行的算法跟上述相同。

![伪代码](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816014852568.png)

然后对序列号算法进行分析，对 **Serial** 也是逐字符处理，并将结果保存至 **401669** 处。

![Serial算法分析](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816014207285.png)

同上，执行有符号位除法后， 商存储在 **EAX** 中，余数存储在 **EDX** 中，然后将 **EDX中低字段DL的值** 存储在指定地点，**IDA** 反编译结果如下。

![伪代码](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816014904997.png)

然后对两次运算后得到的数据进行逐字符对比，如果一致则弹窗正确。

![结果对比](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816015201713.png)

循环结束的条件是遍历完 **处理后name** 中的所有字符，所以其实要求 **输入name的长度小于等于serial的长度**， **IDA** 反编译结果如下。

![反编译](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816015530210.png)

显然两次处理后得到的字符串并不相同，这里手动设置标志位，最后弹窗成功。

![弹窗成功](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816015858578.png)

### 注册机编写

#### 原理概述

根据上述代码分析，我们可以对输入的 **Name** 进行计算得到十六进制的值，这个值与 **Serial** 计算得到的值相等就会弹窗成功，我们由这个值来推算 **Serial** ，因为这个值其实等于 **Serial** 算法运算后的余数部分，我们无法得知除数为多少，所以答案可能有多种，我这里只是对除数从1到10进行枚举，如果是 **可打印字符** 则输出。

#### 注册机

```c
#include<stdio.h>
#include<ctype.h>
int main(void)
{
	char name[20];
	char serial[20] = {0};
	while (1)
	{
		printf("Please input your name: ");
		scanf_s("%s", name, 20);
		int i = 0;
		while (name[i] != '\0')
		{
			char c = name[i];
			int x = ((c % 0xa) ^ i) + 2;
			if (x >= 0xa)
				x = x - 0xa;	
			for (int j = 1; j <= 10; j++)
			{
				int y = j * 0xa + x;
				if (y > 32 && y <= 126)
				{
					serial[i] = y;
					break;
				}
			}
			i++;
		}
		printf("Your serial may be : %s\n", serial);
	}
	return 0;
}
```

运行程序，任意输入名称，获取序列号，弹窗成功。

![弹窗成功](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816024700378.png)
