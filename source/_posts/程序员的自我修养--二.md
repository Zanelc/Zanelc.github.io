---
title: 程序员的自我修养--二
abbrlink: b884c480
date: 2023-08-17 00:40:41
categories:
  - [纸上得来终觉浅,程序员的自我修养--链接、装载与库]
tags:
  - 浅析程序运行原理
  - 程序链接过程
index_img: https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/title.png
---

接上一篇文章的内容，接下来对程序的链接过程进行分析。

<!--more-->

**当我们有两个目标文件时，如何将他们链接起来形成一个可执行文件？这个过程中发生了什么？**

### 背景

使用以下两个源代码文件展开分析：

```c
// a.c
extern int shared;
int main()
{
	int a=100;
	swap(&a,&shared);
}

// b.c
int shared=1;
void swap(int* a, int* b)
{
	int temp = *a;
    *a = *b;
    *b = temp;
}

$:gcc -c a.c b.c
```

### 空间与地址分配

**对于多个输入目标文件，链接器如何将他们的各个段合并到输出文件？**

#### 按序叠加

![按序叠加](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230817013511092.png)

这并不是一个很好的方案，因为 **每个段都有一定的地址和空间对齐要求** ，在有很多输入文件的情况下，输出文件将会有很多零散的段，会造成大量的内存碎片。

#### 相似段合并

> 链接器为目标文件分配地址和空间这句话中的“地址和空间”有连个含义：第一个是在输出的可执行文件的空间；第二个是装载后的虚拟地址中的虚拟地址空间。

![相似段合并](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230817013731658.png)

采用这种方法的链接器一般都采用一种叫 **两步链接** 的方法：

1. 空间与地址分配
2. 符号解析与重定位 **这一步是链接过程的核心，特别是重定位过程。**

```bash
// 链接目标文件 a.o b.o
$: ld a.o b.o -e main -o ab
```

查看链接前后地址的分配情况，**VMA** 表示虚拟地址， **LMA** 表示加载地址，**正常情况下，这两个值应该是一样的**。

可以看到，在链接之前，目标文件的所有段的 **VMA** 都是0，因为虚拟空间还没有被分配，默认都为0，等到链接之后，可执行文件 **ab** 中的各个段都被分配到了相应的虚拟地址。

![VMA](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230819014504889.png)

#### 符号地址的确定

**链接后文件中的各个段的虚拟地址就已经确定了**，因为各个符号在段内的相对位置是固定的，所以这时候 **main、shared、swap** 的地址也已经是确定的了，只不过链接器需要给每个符号加上一个 **偏移量**，使它们能够调整到正确的虚拟地址。

![虚拟地址确定](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230819015502205.png)

### 符号解析和重定位

#### 重定位

> 在完成空间和地址的分配步骤以后，链接器就进入了符号解析与重定位的步骤，这也是静态链接的核心内容。

[GCC内联汇编的基础](http://blog.chinaunix.net/uid-20605433-id-1617453.html)

```assembly
$:objdump -d a.o
a.o:     file format elf64-x86-64
Disassembly of section .text:
0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
   c:   c7 45 fc 64 00 00 00    movl   $0x64,-0x4(%rbp)
  13:   48 8d 45 fc             lea    -0x4(%rbp),%rax
  17:   48 8d 15 00 00 00 00    lea    0x0(%rip),%rdx        # 1e <main+0x1e>
  1e:   48 89 d6                mov    %rdx,%rsi
  21:   48 89 c7                mov    %rax,%rdi
  24:   b8 00 00 00 00          mov    $0x0,%eax
  29:   e8 00 00 00 00          call   2e <main+0x2e>
  2e:   b8 00 00 00 00          mov    $0x0,%eax
  33:   c9                      leave
  34:   c3                      re
```

在程序的代码里面使用的都是 **虚拟地址** ，可以看到 **main** 的其实地址为 0，这是因为在未进行空间分配之前，目标文件代码段中的起始地址以 0 开始，等到空间分配完成以后，各个函数才会确定自己在虚拟地址空间中的位置。

当 **a.c** 被编译成目标文件时，编译器并不知道 **shared** 和 **swap** 的地址，因为它们定义在其他目标文件中，所以编译器暂时 **把0看作是他们的地址，把真正的计算地址工作留给了链接器**。

![链接前](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230819021437854.png)

链接器可以根据符号的地址对每个需要重定位的指令进行地址修正，修正后引用的地址都被替换掉。

![image-20230819022744397](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230819022744397.png)

#### 重定位表

链接器是怎么知道哪些指令需要被调整的呢？这些指令的哪些部分需要被调整？怎么调整？

**重定位表** 专门负责保存这些与重定位相关的信息，在ELF文件中往往是一个或多个段。

![重定位表](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230819023221699.png)

#### 符号解析

> 之所以要链接是因为我们目标文件中用到的符号被定义在其他目标文件，所以要将它们链接起来

如果只链接一个文件，链接器就会发现 **shared** 和 **swap** 两个符号没有定义，没办法完成链接工作。

```bash
$:ld a.o -e main
ld: a.o: in function `main':
a.c:(.text+0x1a): undefined reference to `shared'
ld: a.c:(.text+0x2a): undefined reference to `swap
```

查看 **a.o** 的符号表, **GLOBAL** 类型的符号，除了 **main** 函数是定义在代码段之外，其他两个 **shared** 和 **swap** 都是 **UND** ，即 **undefined** 未定义类型，**这种未定义的符号都是因为该目标文件中有关于它们的重定位项。** 链接器在扫描完所有的输入目标文件之后，所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误。

```assembly
，$:readelf -s a.o
Symbol table '.symtab' contains 6 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000000    53 FUNC    GLOBAL DEFAULT    1 main
     4: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND shared
     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND swap
```

### 静态库链接

```markdown
{% note success %}
程序之所以有用，因为它会有输入输出，这些输入输出的对象可以是数据，可以是人，也可以是另外一种程序，还可以是另外一台计算机，一个没有输入输出的程序没有任何意义。
{% endnote %}
```

> 一般情况下，一种语言的开发环境往往会附带有语言库，这些库就是对操作系统API的封装，比如 printf 函数对字符串进行一些必要的处理后，最后会调用操作系统提供的API。很大一部分库函数都是要调用操作系统API的。

**静态库可以简单的看出一组目标文件的集合**

把零散的目标文件直接提供给库的使用者，很大程度上会造成文件传输、管理和组织的不便，通常使用 **ar** 压缩程序讲这些目标文件压缩在一起，并对其进行 **编号和索引**，以便于查找和检索，就形成了静态库文件。

例如，我们可以使用 **ar** 工具来查看 **libc.a** 静态库文件包含了哪些目标文件：

![ar查看静态库](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230820000307422.png)

查看 **printf** 函数所在的目标文件，可以看到 **printf** 被定义在了 **printf.o** 这个目标文件中。

```
$:objdump -t /usr/lib32/libc.a | grep printf
...
printf.o:     file format elf32-i386
00000000 g     F .text  0000002d __printf
00000000         *UND*  00000000 .hidden __vfprintf_internal
00000000 g     F .text  0000002d _IO_printf
00000000 g     F .text  0000002d print
...
```

**ld** 链接起会自动寻找所有需要的符号以及它们所在的目标文件，将这些目标文件从 **libc.a** 中 **解压** 出来，最终将它们链接成为一个可执行文件。

![静态链接](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230820001045509.png)
