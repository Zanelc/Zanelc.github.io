---
title: 程序员的自我修养--三
categories:
  - - 纸上得来终觉浅
    - 程序员的自我修养--链接、装载与库
tags:
  - 浅析程序运行原理
  - 程序链接过程
abbrlink: fad8528d
date: 2023-08-20 00:43:49
index_img: https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/fad8528d/title.png
---
主要理解动态链接的基本思想与装载过程，不深究其实现方式。
<!--more-->

### 进程虚拟地址空间

**可执行程序只有装在到内存以后才能被CPU执行。每个程序被运行起来以后，它将拥有自己的独立的虚拟地址空间。**

32位平台决定了虚拟地址空间的地址为 0~2^32-1,即 **0x00000000-0xFFFFFFFF**，也就是我们常说的 **4GB** 虚拟空间大小，而64位的硬件平台具有64位寻址能力，几乎是无限的。

那么32位平台下的 **4GB** 虚拟空间，我们的程序是否可以任意使用呢？

> 不行，因为程序在运行时候处于操作系统的监管下，操作系统为了达到监控程序运行等一系列目的，进程的虚拟空间都在操作系统的掌控之中。进程只能使用那些操作系统分配给进程的地址，如果访问未经允许的空间，那么操作系统就会捕获到这些访问，将进程的这种访问当做非法操作，强制结束进程。

![Linux进程虚拟空间分布](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/fad8528d/image-20230820010745909.png)

整个 **4GB** 被划分为两部分，其中操作系统本身用去了一部分，从地址 **0xc0000000到0xffffffff**，共 **1GB**。剩下的共 **3GB** 空间都是留给进程使用的。

#### 装载的方式

> 程序执行时所需要的指令和数据必须在内存中才能正常运行，最简单的方法就是将程序所需要的指令和数据全部都装入内存中，这样程序就可以顺利执行，这就是最简单的 **静态装入** 的办法。但是很多情况下程序所需要的内存数量远大于物理内存输了，后来研究发现，程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是 **动态装入** 的基本原理

### 从操作系统角度看可执行文件的装载

**有了硬件的地址转换和页映射机制，操作系统动态加载可执行文件的方式跟静态加载有了很大的区别。**

#### 进程的建立

从操作系统的角度来看，一个进程最关键的特征是它 **拥有独立的虚拟地址空间**，这使得它有别于其他进程。

在有虚拟存储的情况下，只需要做三件事：

1. 创建一个独立的虚拟地址空间
2. 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系
3. 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行

**由于可执行文件在装载时实际上是被映射的虚拟地址空间，所以可执行文件很多时候被叫做映像文件。**

#### 页错误

上述步骤执行完以后，**可执行文件的真正指令和数据都没有被装入到内存中**，操作系统只是通过可执行文件头部的信息建立可执行文件和进程虚拟内存之间的映射关系而已。

随着程序的执行， **页错误** 会不断产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。

> **Segment** 的概念实际上是从装载的角度重新划分了ELF的各个段，在将目标文件链接成可执行文件的时候，链接器会尽量把相同权限属性的段分配在同一空间。在ELF中把这些属性相似的、又连在一起的段叫做一个 **Segment** ，而系统正是按照 **Segment** 而不是 **Section** 来映射可执行文件的。

### Window PE 的装载

**RVA：相对虚拟地址，相当于文件中偏移量。**

> 每个PE文件在装载时都会有一个装载目标地址，这个地址就是所谓的 **基地址** ，由于PE文件被这几场可以装载到任何地址，所以这个基地址并不是固定的，每次装载时都可能会变化。如果PE文件中的地址都使用绝对地址，它们都要随着基地址的变化而变化，但是如果使用RVA这样一种基于基地址的相对地址，那么无论基地址怎么变化，PE文件中的RVA都保持一致。

### 动态链接

静态链接对于计算机内存和磁盘的 **空间浪费** 非常严重，同时对程序的 **更新、部署和发布** 也会带来很多麻烦，即一旦程序中有任何模块更新，整个程序就要重新链接、发布给用户。

**把链接过程推迟到运行时再进行，这就是动态链接的基本思想。动态链接把程序按照模块拆分成各个相对独立的部分，在程序运行时才将它们连接在一起形成一个完整的程序，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件。**

在Linux系统中， **ELF** 动态链接文件被称为 **动态共享对象** ，简称 **共享对象，一般是以 ".so" 为扩展名的一些文件**；而在 **Windows** 系统中，动态链接文件被称为 **动态链接库，它们就是平时常见的以 ".dll" 为扩展名的文件。**

> 动态链接会导致程序性能的一些损失(程序每次装载时都要重新进行链接)，但是用这点性能损失换取程序在空间上的节省和程序构建和升级的灵活性，是相当值得的。

通过一个简单的例子来大致感受一下动态链接：

```c
// lib.h
#ifndef LIB_H
#define LIB_H
void foobar(int i);
#endif

//lib.c
#include<stdio.h>
void foobar(int i)
{
        printf("Printing from lib.so %d\n",i);
}

//program1.c
#include "lib.h"
int main()
{
        foobar(1);
        return 0;
}

//program2.c
#include "lib.h"
int main()
{
        foobar(2);
        return 0;
}

// 将lib.c编译成一个共享文件对象
$:gcc -fPIC -shared -o lib.so lib.c

// 编译目标文件
$:gcc -o program1 program1.c lib.so
$:gcc -o program2 program2.c lib.so
```

从 **program1** 的角度来看，整个编译和链接过程如下图所示

![动态链接过程](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/fad8528d/image-20230820175441567.png)

在静态链接过程中，链接会把 **program1.o** 和 **lib.o** 链接在一起，并且产生输出可执行文件 **program1** ，但是在这里， **lib.o** 没有被链接进来，链接的输入目标文件只有 **program1.o** ，但是 **lib.so** 也参与了链接过程，这是怎么回事呢？

> 在静态链接时，程序最终只有一个可执行文件，它是一个不可分割的整体；但是在动态链接下，一个程序被分成了若干个文件，有程序的主要部分，即可执行文件(program1)和程序所依赖的共享对象(lib.so)，很多时候我们也把这些部分称为 **模块** ，即 **动态链接下的可执行文件和共享对象都可以看作是程序的一个模块** 。

当链接器将 **program1.o** 链接成可执行文件时，这时候链接器必须确定 **program1.o** 中所引用的 **foobar()** 函数的性质。如果 **foobar()** 是一个定义与其他静态目标模块中的函数，那么链接器将会按照静态链接的规则，将 **program1.o** 中的 **foobar** 地址引用重定位；如果 **foobar()** 是一个定义在某个动态共享对象中的函数，那么链接器就会将这个符号的引用标记为一个动态链接的符号， **不对它进行地址重定位，把这个过程留到装载时再进行。**

**lib.so 保存了完整的符号信息，把它也作为链接的输入文件之一，链接器在解析符号时就可以知道：foobar是一个定义在lib.so 的动态符号，这样链接器就可以对foobar的引用做特殊处理，使它成为一个对动态符号的引用。**

### Windows下动态链接

**DLL** 即动态链接库的缩写，它相当于linux下的共享对象。

**PE** 里面有两个很常用的概念就是 **基地址** 和 **相对地址**，当一个 **PE** 文件被装载时，其进程地址空间中的起始地址就是基地址。在DLL文件中，需要 **显式** 告诉编译器我们需要导出某个符号，否则编译器默认所有符号都不导出，当在程序中使用 **DLL** 导出的符号时，这个过程被称为 **导入** 。

程序使用 **DLL** 的过程其实是引用 **DLL** 中的导出函数和符号的过程。导出表从最简单的结构上来看，它提供了一个符号名与符号地址的映射关系，即可以通过某个符号查找相应的地址。
