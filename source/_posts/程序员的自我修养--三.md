---
title: 程序员的自我修养--三
categories:
  - - 纸上得来终觉浅
    - 程序员的自我修养--链接、装载与库
tags:
  - 浅析程序运行原理
  - 程序链接过程
abbrlink: fad8528d
date: 2023-08-20 00:43:49
index_img: https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/fad8528d/title.png
---



<!--more-->

### 进程虚拟地址空间

**可执行程序只有装在到内存以后才能被CPU执行。每个程序被运行起来以后，它将拥有自己的独立的虚拟地址空间。**

32位平台决定了虚拟地址空间的地址为 0~2^32-1,即 **0x00000000-0xFFFFFFFF**，也就是我们常说的 **4GB** 虚拟空间大小，而64位的硬件平台具有64位寻址能力，几乎是无限的。

那么32位平台下的 **4GB** 虚拟空间，我们的程序是否可以任意使用呢？

> 不行，因为程序在运行时候处于操作系统的监管下，操作系统为了达到监控程序运行等一系列目的，进程的虚拟空间都在操作系统的掌控之中。进程只能使用那些操作系统分配给进程的地址，如果访问未经允许的空间，那么操作系统就会捕获到这些访问，将进程的这种访问当做非法操作，强制结束进程。

![Linux进程虚拟空间分布](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/fad8528d/image-20230820010745909.png)

整个 **4GB** 被划分为两部分，其中操作系统本身用去了一部分，从地址 **0xc0000000到0xffffffff**，共 **1GB**。剩下的共 **3GB** 空间都是留给进程使用的。

#### 装载的方式

> 程序执行时所需要的指令和数据必须在内存中才能正常运行，最简单的方法就是将程序所需要的指令和数据全部都装入内存中，这样程序就可以顺利执行，这就是最简单的 **静态装入** 的办法。但是很多情况下程序所需要的内存数量远大于物理内存输了，后来研究发现，程序运行时是有局部性原理的，所以我们可以将程序最常用的部分驻留在内存中，而将一些不太常用的数据存放在磁盘里面，这就是 **动态装入** 的基本原理

### 从操作系统角度看可执行文件的装载

**有了硬件的地址转换和页映射机制，操作系统动态加载可执行文件的方式跟静态加载有了很大的区别。**

#### 进程的建立

从操作系统的角度来看，一个进程最关键的特征是它 **拥有独立的虚拟地址空**，这使得它有别于其他进程。

在有虚拟存储的情况下，只需要做三件事：

1. 创建一个独立的虚拟地址空间
2. 读取可执行文件头，并且建立虚拟空间与可执行文件的映射关系
3. 将CPU的指令寄存器设置成可执行文件的入口地址，启动运行

**由于可执行文件在装载时实际上是被映射的虚拟地址空间，所以可执行文件很多时候被叫做映像文件。**

#### 页错误

上述步骤执行完以后，**可执行文件的真正指令和数据都没有被装入到内存中**，操作系统只是通过可执行文件头部的信息建立可执行文件和进程虚拟内存之间的映射关系而已。

随着程序的执行， **页错误** 会不断产生，操作系统也会为进程分配相应的物理页面来满足进程执行的需求。

> **Segment** 的概念实际上是从装载的角度重新划分了ELF的各个段，在将目标文件链接成可执行文件的时候，链接器会尽量把相同权限属性的段分配在同一空间。在ELF中把这些属性相似的、又连在一起的段叫做一个 **Segment** ，而系统正是按照 **Segment** 而不是 **Section** 来映射可执行文件的。

### Window PE 的装载

**RVA：相对虚拟地址，相当于文件中偏移量。**

> 每个PE文件在装载时都会有一个装载目标地址，这个地址就是所谓的 **基地址** ，由于PE文件被这几场可以装载到任何地址，所以这个基地址并不是固定的，每次装载时都可能会变化。如果PE文件中的地址都使用绝对地址，它们都要随着基地址的变化而变化，但是如果使用RVA这样一种基于基地址的相对地址，那么无论基地址怎么变化，PE文件中的RVA都保持一致。

### 动态链接
