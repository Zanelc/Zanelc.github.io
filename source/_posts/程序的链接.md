---
title: 程序员的自我修养
categories:
  - 程序员的自我修养--链接、装载与库
tags:
  - 程序运行原理
  - 程序链接过程
index_img: https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/a504920f/title.png
abbrlink: a504920f
date: 2023-08-08 00:27:08
---

对于平常的应用开发，我们很少需要关注编译和链接过程，IDE一般都将这一过程帮我们完成，通常将这种编译和链接合并到一起的过程称为 **构建** ，本文特意来探讨软件运行背后的原理。

<!--more-->

### 背景

以 **helloword** 程序为例，代码如下：

```c
// hello.c
#include<stdio.h>
int main(void)
{
	printf("Hello world.\n");
	return 0;
}
```

当对 **hello.c** 进行构建时，**IDE** 帮我们做了以下四件事：**预处理、编译、汇编、链接。**

### 预处理

> 预处理过程主要处理那些源代码文件中以 **“#“** 开始的预编译指令：例如将所有的 **#define** 宏定义展开， **#include** 指令所包含的文件插入到该预编译指令的位置、删除所有注释等。

```bash
// 预处理
gcc -E hello.c -o hello.i
```

执行完该指令后，生成预处理后的 **hello.i** 文件，部分文件内容如下：

```C
// hello.i 部分文件内容
部分文件内容已省略
...
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_l(const wchar_t *_Format,_locale_t _Locale,...);

  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);
# 1398 "C:/Program Files/Mingw-w64/x86_64-8.1.0-release-win32-seh-rt_v6-rev0/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

# 1 "C:/Program Files/Mingw-w64/x86_64-8.1.0-release-win32-seh-rt_v6-rev0/mingw64/x86_64-w64-mingw32/include/_mingw_print_pop.h" 1 3
# 1400 "C:/Program Files/Mingw-w64/x86_64-8.1.0-release-win32-seh-rt_v6-rev0/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3
# 2 ".\\hello.c" 2

# 2 ".\\hello.c"
int main(void)
{
 printf("Hello world.\n");
 return 0;
}

```

可以发现，程序中 **#include** 指令已经在预处理阶段被替换为其包含的文件内容。

### 编译

> 编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化，然后产生相应的 **汇编代码** 文件。

```bash
// 编译
gcc -S hello.i -o hello.s
```

生成目标文件 **hello.s** ，内容如下：

```c
// hello.s 文件内容
	.file	"hello.c"
	.text
	.def	__main;	.scl	2;	.type	32;	.endef
	.section .rdata,"dr"
.LC0:
	.ascii "Hello world.\0"
	.text
	.globl	main
	.def	main;	.scl	2;	.type	32;	.endef
	.seh_proc	main
main:
	pushq	%rbp
	.seh_pushreg	%rbp
	movq	%rsp, %rbp
	.seh_setframe	%rbp, 0
	subq	$32, %rsp
	.seh_stackalloc	32
	.seh_endprologue
	call	__main
	leaq	.LC0(%rip), %rcx
	call	puts
	movl	$0, %eax
	addq	$32, %rsp
	popq	%rbp
	ret
	.seh_endproc
	.ident	"GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0"
	.def	puts;	.scl	2;	.type	32;	.endef

```

这里可以看到生成的汇编格式与我们平常见到的 **Intel汇编** 语法有所不同，主要取决于使用的工具和平台，**GCC编译器使用了 AT&T/UNIX 汇编语法**。

### 汇编

> 汇编器是将汇编代码转变为机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。

源代码文件经过预处理、编译和汇编后生成 **目标文件**。

```bash
// 汇编
gcc -c hello.s -o hello.o
```

目标文件为**二进制文件**，可以使用 **file、objdump、hexdump**来查看该文件信息：

```bash
$:file hello.o
hello.o: Intel amd64 COFF object file, no line number info, not stripped, 7 sections, symbol offset=0x200, 20 symbols, 1st section name ".text"
```

汇编之后的所有的全局变量以及函数的入口地址都被暂时设置为 **0** ，不能直接使用，需要下一个步骤， 链接。

### 链接

> 目标代码中有变量定义在其他模块，该怎么办？事实上，定义其他模块的1全局变量和函数在最终运行时的绝对地址都要在最终链接时才能确定。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。

链接过程主要包括了 **地址和空间分配、符号决议和重定位** 等步骤。

假设有个全局变量叫 **var** ，它在目标文件 **A** 里面，我们要在目标文件 **B** 里面访问这个全局变量，目标文件 **B** 里面有这样一条指令：

```c
// 相当于C语言中的 var=42
movl $0x2a,var
```

我们这里来实践查看一下效果：

```c
// vim test.c  extern指明var为外部引用
#include<stdio.h>
extern int var;
int main(void)
{
        var=42;
        return 0;
}

// 将源代码编译成目标文件
$:gcc -E test.c -o test.i
$:gcc -S test.i -o test.s
$:gcc -c test.s -o test.o

// 使用objdump来查看反汇编代码
$:objdump -d test.o
Disassembly of section .text:

0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   c7 05 00 00 00 00 2a    movl   $0x2a,0x0(%rip)        # 12 <main+0x12>
   f:   00 00 00
  12:   b8 00 00 00 00          mov    $0x0,%eax
  17:   5d                      pop    %rbp
  18:   c3                      ret
```

可以看到，指令 **movl $0x2a,var** 对应的机器码为 **c7 05 00 00 00 00 2a** ，由于编译目标文件时候，编译器并不知道变量 **var** 的地址，所以将这条 **mov** 指令的地址置为0，等待 **链接器将目标文件A和目标文件B链接起来的时候再将其修正**，这个修正的过程也叫做 **重定位**。
