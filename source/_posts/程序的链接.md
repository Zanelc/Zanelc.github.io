---
title: 程序员的自我修养
categories:
  - 程序员的自我修养--链接、装载与库
tags:
  - 程序运行原理
  - 程序链接过程
index_img: https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/a504920f/title.png
abbrlink: a504920f
date: 2023-08-08 00:27:08
---

对于平常的应用开发，我们很少需要关注编译和链接过程，IDE一般都将这一过程帮我们完成，通常将这种编译和链接合并到一起的过程称为 **构建** ，本文特意来探讨软件运行背后的原理。

<!--more-->

{% note danger %}
实践是检验真理的唯一标准
{% endnote %}

### 背景

以 **helloword** 程序为例，代码如下：

```c
// hello.c
#include<stdio.h>
int main(void)
{
	printf("Hello world.\n");
	return 0;
}
```

当对 **hello.c** 进行构建时，**IDE** 帮我们做了以下四件事：**预处理、编译、汇编、链接。**

### 预处理

> 预处理过程主要处理那些源代码文件中以 **“#“** 开始的预编译指令：例如将所有的 **#define** 宏定义展开， **#include** 指令所包含的文件插入到该预编译指令的位置、删除所有注释等。

```bash
// 预处理
gcc -E hello.c -o hello.i
```

执行完该指令后，生成预处理后的 **hello.i** 文件，部分文件内容如下：

```C
// hello.i 部分文件内容
部分文件内容已省略
...
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _snwscanf_l(const wchar_t *_Src,size_t _MaxCount,const wchar_t *_Format,_locale_t _Locale,...);
  __attribute__ ((__dllimport__)) int __attribute__((__cdecl__)) _wscanf_l(const wchar_t *_Format,_locale_t _Locale,...);

  __attribute__ ((__dllimport__)) size_t __attribute__((__cdecl__)) _fread_nolock_s(void *_DstBuf,size_t _DstSize,size_t _ElementSize,size_t _Count,FILE *_File);
# 1398 "C:/Program Files/Mingw-w64/x86_64-8.1.0-release-win32-seh-rt_v6-rev0/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3

# 1 "C:/Program Files/Mingw-w64/x86_64-8.1.0-release-win32-seh-rt_v6-rev0/mingw64/x86_64-w64-mingw32/include/_mingw_print_pop.h" 1 3
# 1400 "C:/Program Files/Mingw-w64/x86_64-8.1.0-release-win32-seh-rt_v6-rev0/mingw64/x86_64-w64-mingw32/include/stdio.h" 2 3
# 2 ".\\hello.c" 2

# 2 ".\\hello.c"
int main(void)
{
 printf("Hello world.\n");
 return 0;
}

```

可以发现，程序中 **#include** 指令已经在预处理阶段被替换为其包含的文件内容。

### 编译

> 编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化，然后产生相应的 **汇编代码** 文件。

```bash
// 编译
gcc -S hello.i -o hello.s
```

生成目标文件 **hello.s** ，内容如下：

```assembly
// hello.s 文件内容
	.file	"hello.c"
	.text
	.def	__main;	.scl	2;	.type	32;	.endef
	.section .rdata,"dr"
.LC0:
	.ascii "Hello world.\0"
	.text
	.globl	main
	.def	main;	.scl	2;	.type	32;	.endef
	.seh_proc	main
main:
	pushq	%rbp
	.seh_pushreg	%rbp
	movq	%rsp, %rbp
	.seh_setframe	%rbp, 0
	subq	$32, %rsp
	.seh_stackalloc	32
	.seh_endprologue
	call	__main
	leaq	.LC0(%rip), %rcx
	call	puts
	movl	$0, %eax
	addq	$32, %rsp
	popq	%rbp
	ret
	.seh_endproc
	.ident	"GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0"
	.def	puts;	.scl	2;	.type	32;	.endef

```

这里可以看到生成的汇编格式与我们平常见到的 **Intel汇编** 语法有所不同，主要取决于使用的工具和平台，**GCC编译器使用了 AT&T/UNIX 汇编语法**。

### 汇编

> 汇编器是将汇编代码转变为机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。

源代码文件经过预处理、编译和汇编后生成 **目标文件**。

```bash
// 汇编
gcc -c hello.s -o hello.o
```

目标文件为**二进制文件**，可以使用 **file、objdump、hexdump**来查看该文件信息：

```bash
$:file hello.o
hello.o: Intel amd64 COFF object file, no line number info, not stripped, 7 sections, symbol offset=0x200, 20 symbols, 1st section name ".text"
```

汇编之后的所有的全局变量以及函数的入口地址都被暂时设置为 **0** ，不能直接使用，需要下一个步骤， 链接。

### 链接

> 目标代码中有变量定义在其他模块，该怎么办？事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接时才能确定。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。

链接过程主要包括了 **地址和空间分配、符号决议和重定位** 等步骤。

假设有个全局变量叫 **var** ，它在目标文件 **A** 里面，我们要在目标文件 **B** 里面访问这个全局变量，目标文件 **B** 里面有这样一条指令：

```c
// 相当于C语言中的 var=42
movl $0x2a,var
```

我们这里来实践查看一下效果：

```assembly
// vim test.c  extern指明var为外部引用
#include<stdio.h>
extern int var;
int main(void)
{
        var=42;
        return 0;
}

// 将源代码编译成目标文件
$:gcc -E test.c -o test.i
$:gcc -S test.i -o test.s
$:gcc -c test.s -o test.o

// 使用objdump来查看反汇编代码
$:objdump -d test.o
Disassembly of section .text:

0000000000000000 <main>:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   c7 05 00 00 00 00 2a    movl   $0x2a,0x0(%rip)        # 12 <main+0x12>
   f:   00 00 00
  12:   b8 00 00 00 00          mov    $0x0,%eax
  17:   5d                      pop    %rbp
  18:   c3                      ret
```

可以看到，指令 **movl $0x2a,var** 对应的机器码为 **c7 05 00 00 00 00 2a** ，由于编译目标文件时候，编译器并不知道变量 **var** 的地址，所以将这条 **mov** 指令的地址置为0，等待 **链接器将目标文件A和目标文件B链接起来的时候再将其修正**，这个修正的过程也叫做 **重定位**。

### 目标文件格式

目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能**有些符号或有些地址还没有被调整**。

常见的按照 **可执行文件格式** 存储的文件，他们都是 **COFF(Common file format)** 格式的变种：

- Windows下的 **PE(Portable Executable)** 文件
- Linux下的 **ELF(Executable Linkable Format)** 文件
- 动态链接库 **DLL(Dynamic Linking Library)**
- 静态链接库 **LIB(Static Linking Library)**

**目标文件跟可执行文件的内容和结构很相似，所以一般跟可执行文件格式一起采用一种格式存储。**

#### 目标文件是什么样的

目标文件的内容至少有编译后的机器指令 **代码、数据**，除了这些，还包括链接时所必需的一些信息，比如 **符号表、调试信息、字符串** 等。 **一般目标文件将这些信息按不同的属性，以 “节” 的形式存储，有时也叫 “段”，它们都表示一个一定长度的区域**。

- 代码段(**.code 或 .text**)：编译后的机器指令通常被放在代码段
- 数据段(**.data**)：已初始化全局变量和局部静态变量经常存放在数据段
- **.bss**：未初始化全局变量和局部静态变量

**示例分析**

```c
// simplesection.c
int printf(const char* format,...);
int global_init_var=84;
int global_uninit_var;
void func1(int i)
{
        printf("%d\n",i);
}
int main(void)
{
        static int static_var=85;
        static int static_var2;
        int a=1;
        int b;
        func1(static_var+static_var2+a+b);
        return a;
}

// 生成目标文件 -c表示不链接
$: gcc -c simplesection.c -o simplesection.o
    
// 使用objdump查看节表信息
$: objdump -h simplesection.o
 simplesection.o:     file format elf64-x86-64

Sections:
Idx Name          Size      VMA               LMA               File off  Algn
  0 .text         00000062  0000000000000000  0000000000000000  00000040  2**0
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000008  0000000000000000  0000000000000000  000000a4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000008  0000000000000000  0000000000000000  000000ac  2**2
                  ALLOC
  3 .rodata       00000004  0000000000000000  0000000000000000  000000ac  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .comment      0000002e  0000000000000000  0000000000000000  000000b0  2**0
                  CONTENTS, READONLY
  5 .note.GNU-stack 00000000  0000000000000000  0000000000000000  000000de  2**0
                  CONTENTS, READONLY
  6 .note.gnu.property 00000020  0000000000000000  0000000000000000  000000e0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .eh_frame     00000058  0000000000000000  0000000000000000  00000100  2**3
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA
```

可以看到，除了基本的代码段、数据段、BSS段外，还有好多其他的段，这里暂且不去深究。

##### 代码段

使用 **objdump** 来查看所有段的内容，可以看到  **.text** 段跟我们前面得到的长度相符合，对照下面的 **反汇编结果** ，可以很明显的看到，**.text** 段里面包含的正是源文件中两个函数 **func1()** 和 **main()** 指令。

```assembly
// -s 十六进制打印所有段内容  -d 反汇编
$:objdump -s -d simplesection.o
simplesection.o:     file format elf64-x86-64

Contents of section .text:
 0000 f30f1efa 554889e5 4883ec10 897dfc8b  ....UH..H....}..
 0010 45fc89c6 488d0500 00000048 89c7b800  E...H......H....
 0020 000000e8 00000000 90c9c3f3 0f1efa55  ...............U
 0030 4889e548 83ec10c7 45f80100 00008b15  H..H....E.......
 0040 00000000 8b050000 000001c2 8b45f801  .............E..
 0050 c28b45fc 01d089c7 e8000000 008b45f8  ..E...........E.
 0060 c9c3                                 ..
......
Disassembly of section .text:

0000000000000000 <func1>:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
   c:   89 7d fc                mov    %edi,-0x4(%rbp)
   f:   8b 45 fc                mov    -0x4(%rbp),%eax
  12:   89 c6                   mov    %eax,%esi
  14:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 1b <func1+0x1b>
  1b:   48 89 c7                mov    %rax,%rdi
  1e:   b8 00 00 00 00          mov    $0x0,%eax
  23:   e8 00 00 00 00          call   28 <func1+0x28>
  28:   90                      nop
  29:   c9                      leave
  2a:   c3                      ret

000000000000002b <main>:
  2b:   f3 0f 1e fa             endbr64
  2f:   55                      push   %rbp
  30:   48 89 e5                mov    %rsp,%rbp
  33:   48 83 ec 10             sub    $0x10,%rsp
  37:   c7 45 f8 01 00 00 00    movl   $0x1,-0x8(%rbp)
  3e:   8b 15 00 00 00 00       mov    0x0(%rip),%edx        # 44 <main+0x19>
  44:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 4a <main+0x1f>
  4a:   01 c2                   add    %eax,%edx
  4c:   8b 45 f8                mov    -0x8(%rbp),%eax
  4f:   01 c2                   add    %eax,%edx
  51:   8b 45 fc                mov    -0x4(%rbp),%eax
  54:   01 d0                   add    %edx,%eax
  56:   89 c7                   mov    %eax,%edi
  58:   e8 00 00 00 00          call   5d <main+0x32>
  5d:   8b 45 f8                mov    -0x8(%rbp),%eax
  60:   c9                      leave
  61:   c3                      ret
```

##### 数据段和只读数据段

**.data** 段保存了已经初始化的全局变量和局部静态变量，源代码中共有两个这样的变量，分别为 **global_init_var** 与 **static_var**。

```
// .data段和.rodata段
Contents of section .data:
 0000 54000000 55000000                    T...U...
Contents of section .rodata:
 0000 25640a00                             %d..
```

可以看到 **.data** 段为8个字节，分别为 **0x54、0x55**，对应源代码中的静态变量。

**.rodata** 段存放的是只读数据，一般是程序里面的只读变量(如const修饰的变量)和字符串常量。上述源程序在调用 **printf** 的时候，用到了一个字符串常量 **"%d\\n"** ，它是一种只读数据，所以被放到了 **.rodata** 段，**输出结果可以看到.rodata段的前四个字节刚好是这个字符串常量的ASCII字节序，最后以 **\\0** 结尾。

有时候编译器也会把字符串常量放到 **.data** 段，而不是单独放在 **.rodata** 段。

#####  BSS段

**.bss** 段存放的是未初始化的全局变量和局部静态变量，上述源代码中 **global_uninit_var** 和 **static_var2**就是存放在 **.bss** 段。

未初始化的全局变量和局部静态变量默认值都为 **0** ，为他们空间并且保存数据 **0** 是没有必要的，所以 **.bss 段并没有内容，在文件中也不占据磁盘空间**，在可执行文件中，只会记录BSS段所需的内存大小信息，而不会存储实际的BSS数据。

```assembly
// 查看符号表
$: objdump -t simplesection.o
simplesection.o:     file format elf64-x86-64

SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 simplesection.c
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000000 l    d  .rodata        0000000000000000 .rodata
0000000000000004 l     O .data  0000000000000004 static_var.1
0000000000000004 l     O .bss   0000000000000004 static_var2.0
0000000000000000 g     O .data  0000000000000004 global_init_var
0000000000000000 g     O .bss   0000000000000004 global_uninit_var
0000000000000000 g     F .text  000000000000002b func1
0000000000000000         *UND*  0000000000000000 printf
000000000000002b g     F .text  0000000000000037 main
```

查看目标文件的符号表，可以看到上述两个变量 **global_uninit_var、static_var2** 存储在 **.bss** 段。 

### ELF文件结构

![ELF文件结构](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/a504920f/elf-file-format.png)

#### 文件头

对照ELF的文件结构，查看目标文件的文件头：

```sh
// 查看目标文件Header
$: readelf -h simplesection.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          1032 (bytes into file)		//段表的起始地址，也就是偏移
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         14							// 段的数量,可以用readelf -S 查看所有段
  Section header string table index: 13
```

#### 段表

在文件头中，已经看到，段表的偏移地址为1032，对应的十六进制为 **0x408**，查看段表信息：

```
$: readelf -S simplesection.o
There are 14 section headers, starting at offset 0x408:

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000		//第一个元素是无效的段描述符，类型为NULL
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000062  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  000002e8		//重定位表
       0000000000000078  0000000000000018   I      11     1     8
  [ 3] .data             PROGBITS         0000000000000000  000000a4
       0000000000000008  0000000000000000  WA       0     0     4
  [ 4] .bss              NOBITS           0000000000000000  000000ac
       0000000000000008  0000000000000000  WA       0     0     4
  [ 5] .rodata           PROGBITS         0000000000000000  000000ac
       0000000000000004  0000000000000000   A       0     0     1
  [ 6] .comment          PROGBITS         0000000000000000  000000b0
       0000000000000027  0000000000000001  MS       0     0     1
  [ 7] .note.GNU-stack   PROGBITS         0000000000000000  000000d7
       0000000000000000  0000000000000000           0     0     1
  [ 8] .note.gnu.pr[...] NOTE             0000000000000000  000000d8
       0000000000000020  0000000000000000   A       0     0     8
  [ 9] .eh_frame         PROGBITS         0000000000000000  000000f8
       0000000000000058  0000000000000000   A       0     0     8
  [10] .rela.eh_frame    RELA             0000000000000000  00000360
       0000000000000030  0000000000000018   I      11     9     8
  [11] .symtab           SYMTAB           0000000000000000  00000150
       0000000000000138  0000000000000018          12     8     8
  [12] .strtab           STRTAB           0000000000000000  00000288
       0000000000000060  0000000000000000           0     0     1
  [13] .shstrtab         STRTAB           0000000000000000  00000390
       0000000000000074  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)
```

我们在前面得到段表的其实偏移地址为 **1032**，每个段描述符的大小为 **64** ，共 **14** 个段描述符，可以计算段表结束地址为：**1032+64*14=0x788**，也就是 **simplesection.o** 文件结束地址。

![文件结束地址](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/a504920f/image-20230809010147023.png)

上述段表中，存在一个 **.rela.text** 段，他的类型为 **RELA **，表示它是一个重定位表。链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，即代码段和数据段中对绝对地址引用的位置。
