---
title: 序列号生成算法分析三
categories:
  - - 使用Ollydbg从零开始Cracking
    - xdbg使用
tags:
  - xdbg基础使用
  - 序列号算法分析
  - 菜鸡逆向
abbrlink: e0d0a40
date: 2023-09-26 22:23:20
index_img: https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e0d0a40/title.png
---

使用上一章节的方法来搜索特征值，确实能够找到输入的序列号，但是跟踪不到实际比较序列号字符串处（能力有限）， 遂换了一种方法，通过使用 IDR 软件来获取函数地址，在 x32dbg 中对该函数下断点来分析得到正确序列号。

<!--more-->

{% note success %}
通往罗马的路不止一条，逆向也没有通解，有时候一个不经意的地址就能解决逆向难题。
{% endnote %}

### crackme_4stz

#### 程序分析

首先打开程序，界面如下，输入 **用户名** 和 **序列号** 才会弹窗：

![程序界面](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/image-20230926223757947.png)

已经尝试过教程中的方法来跟踪，没有跟踪到 **实际序列号** 处，这里就不再使用这种方法。

##### 为什么要使用IDR软件呢？

首先使用 **PEID** 来分析程序信息，检测出程序开发环境为 **Borland Delphi 4.0-5.0**，程序是 **delphi** 开发的

![PEID分析](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/image-20230926224355948.png)

而 **IDR** （全称为 **Interactive Delphi Reconstructor**）是一款开源的 **Delphi** 反编译软件，能够从编译文件中恢复大部分初始的 **Delphi** 源代码的程序

打开 **IDR** 软件，将该程序拖进去分析，检出 **Edit2** 编辑框绑定 **Change** 事件，猜测这个函数就是校验函数，把用户输入的序列号与正确的序列号进行比对，该函数的地址为 **4580B0**：

![IDR分析](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/image-20230926224158316.png)

重新使用 **x32dbg** 载入该程序，**ctrl+G** 跳转至目标地址 **4580B0** 处，并在该处下断点：

![Ctrl+G跳转](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/image-20230926225118646.png)

**F9** 运行程序，输入账号 **crackme** 和序列号，当序列号输入第一个字符 **1** 的时候，触发断点，程序断在 **4580B0** 处：

![触发断点](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/image-20230926225549564.png)

继续 **F8** 单步执行函数，程序在执行完 **call** 调用后，**EAX** 处为 **402134** 地址，猜测该函数为生成序列号的函数（根据用户输入的用户名，来生成相应的序列号）：

![序列号生成](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/image-20230926225932130.png)

继续 **F8** 单步执行，发现 **EAX** 存放用户输入序列号地址， **EDX** 存放正确序列号地址，两处序列号进行比对：

![序列号比对](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/image-20230926230123976.png)

很明显两个序列号是不一样的，双击修改 **ZF** 标志位的值，使跳转失败，继续执行下面代码：

![修改ZF值](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/image-20230926230330698.png)

**F9** 继续执行，成功弹窗！

![成功弹窗](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/image-20230926230404082.png)

重新运行程序，看 **crackme** 对应的序列号是不是 **402134**，验证成功。

![输入正确序列号](https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/image-20230926230538882.png)

{% note success %}
到这里分析就结束了，其实有想过进一步跟踪来分析是如何生成序列号过程的，跟踪了一会还是放弃了，也有跟踪到，还是自己太没耐心了，有时候觉得还是重在理解基本操作，具体的crack部分可以留到以后的crackme挑战再深究，不要在前期太过钻牛角尖。
{% endnote %}
