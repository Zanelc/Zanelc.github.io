<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>程序员的自我修养--三</title>
    <link href="/posts/fad8528d/"/>
    <url>/posts/fad8528d/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>纸上得来终觉浅</category>
      
      <category>程序员的自我修养--链接、装载与库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅析程序运行原理</tag>
      
      <tag>程序链接过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员的自我修养--二</title>
    <link href="/posts/b884c480/"/>
    <url>/posts/b884c480/</url>
    
    <content type="html"><![CDATA[<p>接上一篇文章的内容，接下来对程序的链接过程进行分析。</p><span id="more"></span><p><strong>当我们有两个目标文件时，如何将他们链接起来形成一个可执行文件？这个过程中发生了什么？</strong></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>使用以下两个源代码文件展开分析：</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-nao0aplli9jcte"></i><span>c</span><div class="collapse show" id="collapse-nao0aplli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// a.c</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> shared;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a=<span class="hljs-number">100</span>;<br>swap(&amp;a,&amp;shared);<br>&#125;<br><br><span class="hljs-comment">// b.c</span><br><span class="hljs-type">int</span> shared=<span class="hljs-number">1</span>;<br><span class="hljs-type">void</span> <span class="hljs-title function_">swap</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span><br>&#123;<br><span class="hljs-type">int</span> temp = *a;<br>    *a = *b;<br>    *b = temp;<br>&#125;<br><br>$:gcc -c a.c b.c<br></code></pre></td></tr></table></div></figure><h3 id="空间与地址分配"><a href="#空间与地址分配" class="headerlink" title="空间与地址分配"></a>空间与地址分配</h3><p><strong>对于多个输入目标文件，链接器如何将他们的各个段合并到输出文件？</strong></p><h4 id="按序叠加"><a href="#按序叠加" class="headerlink" title="按序叠加"></a>按序叠加</h4><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230817013511092.png" srcset="/img/load.gif" lazyload alt="按序叠加"></p><p>这并不是一个很好的方案，因为 <strong>每个段都有一定的地址和空间对齐要求</strong> ，在有很多输入文件的情况下，输出文件将会有很多零散的段，会造成大量的内存碎片。</p><h4 id="相似段合并"><a href="#相似段合并" class="headerlink" title="相似段合并"></a>相似段合并</h4><blockquote><p>链接器为目标文件分配地址和空间这句话中的“地址和空间”有连个含义：第一个是在输出的可执行文件的空间；第二个是装载后的虚拟地址中的虚拟地址空间。</p></blockquote><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230817013731658.png" srcset="/img/load.gif" lazyload alt="相似段合并"></p><p>采用这种方法的链接器一般都采用一种叫 <strong>两步链接</strong> 的方法：</p><ol><li>空间与地址分配</li><li>符号解析与重定位 <strong>这一步是链接过程的核心，特别是重定位过程。</strong></li></ol><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-sl46vylli9jcte"></i><span>bash</span><div class="collapse show" id="collapse-sl46vylli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 链接目标文件 a.o b.o<br>$: ld a.o b.o -e main -o ab<br></code></pre></td></tr></table></div></figure><p>查看链接前后地址的分配情况，<strong>VMA</strong> 表示虚拟地址， <strong>LMA</strong> 表示加载地址，<strong>正常情况下，这两个值应该是一样的</strong>。</p><p>可以看到，在链接之前，目标文件的所有段的 <strong>VMA</strong> 都是0，因为虚拟空间还没有被分配，默认都为0，等到链接之后，可执行文件 <strong>ab</strong> 中的各个段都被分配到了相应的虚拟地址。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230819014504889.png" srcset="/img/load.gif" lazyload alt="VMA"></p><h4 id="符号地址的确定"><a href="#符号地址的确定" class="headerlink" title="符号地址的确定"></a>符号地址的确定</h4><p><strong>链接后文件中的各个段的虚拟地址就已经确定了</strong>，因为各个符号在段内的相对位置是固定的，所以这时候 <strong>main、shared、swap</strong> 的地址也已经是确定的了，只不过链接器需要给每个符号加上一个 <strong>偏移量</strong>，使它们能够调整到正确的虚拟地址。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230819015502205.png" srcset="/img/load.gif" lazyload alt="虚拟地址确定"></p><h3 id="符号解析和重定位"><a href="#符号解析和重定位" class="headerlink" title="符号解析和重定位"></a>符号解析和重定位</h3><h4 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h4><blockquote><p>在完成空间和地址的分配步骤以后，链接器就进入了符号解析与重定位的步骤，这也是静态链接的核心内容。</p></blockquote><p><a href="http://blog.chinaunix.net/uid-20605433-id-1617453.html">GCC内联汇编的基础</a></p><figure class="highlight plaintext"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-c3va5zlli9jcte"></i><span>assembly</span><div class="collapse show" id="collapse-c3va5zlli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs assembly">$:objdump -d a.o<br>a.o:     file format elf64-x86-64<br>Disassembly of section .text:<br>0000000000000000 &lt;main&gt;:<br>   0:   f3 0f 1e fa             endbr64<br>   4:   55                      push   %rbp<br>   5:   48 89 e5                mov    %rsp,%rbp<br>   8:   48 83 ec 10             sub    $0x10,%rsp<br>   c:   c7 45 fc 64 00 00 00    movl   $0x64,-0x4(%rbp)<br>  13:   48 8d 45 fc             lea    -0x4(%rbp),%rax<br>  17:   48 8d 15 00 00 00 00    lea    0x0(%rip),%rdx        # 1e &lt;main+0x1e&gt;<br>  1e:   48 89 d6                mov    %rdx,%rsi<br>  21:   48 89 c7                mov    %rax,%rdi<br>  24:   b8 00 00 00 00          mov    $0x0,%eax<br>  29:   e8 00 00 00 00          call   2e &lt;main+0x2e&gt;<br>  2e:   b8 00 00 00 00          mov    $0x0,%eax<br>  33:   c9                      leave<br>  34:   c3                      re<br></code></pre></td></tr></table></div></figure><p>在程序的代码里面使用的都是 <strong>虚拟地址</strong> ，可以看到 <strong>main</strong> 的其实地址为 0，这是因为在未进行空间分配之前，目标文件代码段中的起始地址以 0 开始，等到空间分配完成以后，各个函数才会确定自己在虚拟地址空间中的位置。</p><p>当 <strong>a.c</strong> 被编译成目标文件时，编译器并不知道 <strong>shared</strong> 和 <strong>swap</strong> 的地址，因为它们定义在其他目标文件中，所以编译器暂时 <strong>把0看作是他们的地址，把真正的计算地址工作留给了链接器</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230819021437854.png" srcset="/img/load.gif" lazyload alt="链接前"></p><p>链接器可以根据符号的地址对每个需要重定位的指令进行地址修正，修正后引用的地址都被替换掉。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230819022744397.png" srcset="/img/load.gif" lazyload alt="image-20230819022744397"></p><h4 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h4><p>链接器是怎么知道哪些指令需要被调整的呢？这些指令的哪些部分需要被调整？怎么调整？</p><p><strong>重定位表</strong> 专门负责保存这些与重定位相关的信息，在ELF文件中往往是一个或多个段。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230819023221699.png" srcset="/img/load.gif" lazyload alt="重定位表"></p><h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><blockquote><p>之所以要链接是因为我们目标文件中用到的符号被定义在其他目标文件，所以要将它们链接起来</p></blockquote><p>如果只链接一个文件，链接器就会发现 <strong>shared</strong> 和 <strong>swap</strong> 两个符号没有定义，没办法完成链接工作。</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-z6kcnllli9jcte"></i><span>bash</span><div class="collapse show" id="collapse-z6kcnllli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$:ld a.o -e main<br>ld: a.o: <span class="hljs-keyword">in</span> <span class="hljs-keyword">function</span> `main<span class="hljs-string">&#x27;:</span><br><span class="hljs-string">a.c:(.text+0x1a): undefined reference to `shared&#x27;</span><br>ld: a.c:(.text+0x2a): undefined reference to `swap<br></code></pre></td></tr></table></div></figure><p>查看 <strong>a.o</strong> 的符号表, <strong>GLOBAL</strong> 类型的符号，除了 <strong>main</strong> 函数是定义在代码段之外，其他两个 <strong>shared</strong> 和 <strong>swap</strong> 都是 <strong>UND</strong> ，即 <strong>undefined</strong> 未定义类型，<strong>这种未定义的符号都是因为该目标文件中有关于它们的重定位项。</strong> 链接器在扫描完所有的输入目标文件之后，所有这些未定义的符号都应该能够在全局符号表中找到，否则链接器就报符号未定义错误。</p><figure class="highlight plaintext"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-225kx6lli9jcte"></i><span>assembly</span><div class="collapse show" id="collapse-225kx6lli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">，$:readelf -s a.o<br>Symbol table &#x27;.symtab&#x27; contains 6 entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br>     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS a.c<br>     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text<br>     3: 0000000000000000    53 FUNC    GLOBAL DEFAULT    1 main<br>     4: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND shared<br>     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND swap<br></code></pre></td></tr></table></div></figure><h3 id="静态库链接"><a href="#静态库链接" class="headerlink" title="静态库链接"></a>静态库链接</h3><div class="note note-success">            <p>程序之所以有用，因为它会有输入输出，这些输入输出的对象可以是数据，可以是人，也可以是另外一种程序，还可以是另外一台计算机，一个没有输入输出的程序没有任何意义。</p>          </div><blockquote><p>一般情况下，一种语言的开发环境往往会附带有语言库，这些库就是对操作系统API的封装，比如 printf 函数对字符串进行一些必要的处理后，最后会调用操作系统提供的API。很大一部分库函数都是要调用操作系统API的。</p></blockquote><p><strong>静态库可以简单的看出一组目标文件的集合</strong></p><p>把零散的目标文件直接提供给库的使用者，很大程度上会造成文件传输、管理和组织的不便，通常使用 <strong>ar</strong> 压缩程序讲这些目标文件压缩在一起，并对其进行 <strong>编号和索引</strong>，以便于查找和检索，就形成了静态库文件。</p><p>例如，我们可以使用 <strong>ar</strong> 工具来查看 <strong>libc.a</strong> 静态库文件包含了哪些目标文件：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230820000307422.png" srcset="/img/load.gif" lazyload alt="ar查看静态库"></p><p>查看 <strong>printf</strong> 函数所在的目标文件，可以看到 <strong>printf</strong> 被定义在了 <strong>printf.o</strong> 这个目标文件中。</p><figure class="highlight jboss-cli"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-hag4ymlli9jcte"></i><span>jboss-cli</span><div class="collapse show" id="collapse-hag4ymlli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$<span class="hljs-function">:objdump</span> -t <span class="hljs-string">/usr/lib32/libc.a</span> | grep printf<br><span class="hljs-string">...</span><br>printf.o:     file format elf32-i386<br>00000000 g     F <span class="hljs-string">.text</span>  0000002d __printf<br>00000000         *UND*  00000000 <span class="hljs-string">.hidden</span> __vfprintf_internal<br>00000000 g     F <span class="hljs-string">.text</span>  0000002d _IO_printf<br>00000000 g     F <span class="hljs-string">.text</span>  0000002d print<br><span class="hljs-string">...</span><br></code></pre></td></tr></table></div></figure><p><strong>ld</strong> 链接起会自动寻找所有需要的符号以及它们所在的目标文件，将这些目标文件从 <strong>libc.a</strong> 中 <strong>解压</strong> 出来，最终将它们链接成为一个可执行文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b884c480/image-20230820001045509.png" srcset="/img/load.gif" lazyload alt="静态链接"></p>]]></content>
    
    
    <categories>
      
      <category>纸上得来终觉浅</category>
      
      <category>程序员的自我修养--链接、装载与库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅析程序运行原理</tag>
      
      <tag>程序链接过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序列号生成算法分析二</title>
    <link href="/posts/4c519c4d/"/>
    <url>/posts/4c519c4d/</url>
    
    <content type="html"><![CDATA[<p>暂未开始…</p><span id="more"></span>]]></content>
    
    
    <categories>
      
      <category>使用Ollydbg从零开始Cracking</category>
      
      <category>xdbg使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>菜鸡逆向</tag>
      
      <tag>xdbg基础使用</tag>
      
      <tag>序列号算法分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>序列号生成算法分析一</title>
    <link href="/posts/77d1b2e4/"/>
    <url>/posts/77d1b2e4/</url>
    
    <content type="html"><![CDATA[<p>这里分析的crackme与之前的不同之处在于序列号时基于名称变化的，也就是序列号生成具有一定的算法。</p><span id="more"></span><p class="note note-danger">其实一直都想使用新版x32dbg来取代OD，OD毕竟没人维护了(主要还是界面太古老，在2K显示器上面看着很不舒服)，可是想着又是看的OD的入门教程，就一直没有替换为xdbg，终于今天在经历数次OD加载程序崩溃、转圈、加载不出来后，决定弃用OD采用xdbg来进行逆向学习，尽管xdbg还有很多不完善的地方。在本文中，xdbg对内存下断点会出现各种各样的问题，据说是因为内存对齐的原因，具体不深究，目前流行的解决方法是改为硬件断点，除非遇到xdbg无法解决的问题，不然将会一直采用xdbg进行内容更新。</p><h2 id="CureHead’a"><a href="#CureHead’a" class="headerlink" title="CureHead’a"></a>CureHead’a</h2><h3 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h3><p><strong>注：序列号为数字类型(不要问为什么，就是这样设计的。)</strong></p><p><strong>x32dbg</strong> 加载程序，查看API窗口，发现使用 <strong>GetDlgItemeTextA</strong> 来获取输入。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814005631058.png" srcset="/img/load.gif" lazyload alt="API窗口"></p><p>在该API函数处下断点，运行程序，输入序列号。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814005710615.png" srcset="/img/load.gif" lazyload alt="输入序列号"></p><p>继续 <strong>执行到返回</strong>，输入的 <strong>Name</strong> 存储在缓冲区 <strong>0040218E</strong> 处，<strong>Serial</strong> 存储在缓冲区 <strong>40217E</strong> 处。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814010121513.png" srcset="/img/load.gif" lazyload alt="字符串缓冲区"></p><p>对两处分别下硬件访问断点，看看程序是如何处理输入的名称和序列号，程序访问 <strong>0040218E</strong>断在该处。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814225758008.png" srcset="/img/load.gif" lazyload alt="中断"></p><p>分析该处指令，程序进行逐字符判断，当字符不为0时，将小写字符转化为大写字符，<strong>sub al，0x20</strong> 实现转换，若字符为大写，则继续判断下一个字符，字符不属于字母则直接弹出错误窗口。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814230645433.png" srcset="/img/load.gif" lazyload alt="小写转大写"></p><p>转换为大写后，进行如下算法，<strong>将每个字符的十六进制值进行相加，然后与0x5678进行异或运算，将值存储在EAX中</strong>，至此，对名称处理完毕。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814231132330.png" srcset="/img/load.gif" lazyload alt="算法分析"></p><p>继续运行程序，断在访问序列号处。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234111572.png" srcset="/img/load.gif" lazyload alt="中断"></p><p>分析该处指令，程序对输入的序列号逐字符处理，<strong>如果字符不等于0，将当前字符减去0x30，然后再乘10，最后累加到寄存器EDI中</strong> ，对于输入的数字类型的序列号， <strong>相当于把十六进制字符串转化为10进制字符串 ，最后将结果与0x1234异或运算</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234306504.png" srcset="/img/load.gif" lazyload alt="序列号算法"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234534853.png" srcset="/img/load.gif" lazyload alt="十进制数字"></p><p>对算法分析完毕后，继续运行程序，此时，两次算法过后的字符串分别存储在 <strong>EAX和EBX</strong> 中，对值进行比较，若相同，弹窗成功！</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814234739029.png" srcset="/img/load.gif" lazyload alt="比较"></p><p>明显二者不相同，这里手动把 <strong>ZF</strong> 标志位置1，继续执行，弹窗成功。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230814235058906.png" srcset="/img/load.gif" lazyload alt="弹窗成功"></p><h3 id="注册机编写"><a href="#注册机编写" class="headerlink" title="注册机编写"></a>注册机编写</h3><h4 id="原理概述"><a href="#原理概述" class="headerlink" title="原理概述"></a>原理概述</h4><p>通过对上面程序的逐过程分析，我们了解到程序的大致原理：输入名称和序列号，程序会对名称和序列号进行一定的算法，然后比较，二者相同则弹窗成功。</p><p><strong>对名称处理：将输入名称中的小写字符全部转为大写字符，然后逐个字符相加，结果与0x5678异或</strong></p><p><strong>对序列号处理：将输入序列号的字符转化为10进制数字，结果与0x1234异或</strong></p><p><strong>根据异或特性，我们只需将对名称处理后的序列号与0x1234进行异或即可得到10进制序列号。</strong></p><h4 id="注册机"><a href="#注册机" class="headerlink" title="注册机"></a><strong>注册机</strong></h4><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-swqjd2lli9jctd"></i><span>C</span><div class="collapse show" id="collapse-swqjd2lli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input your name: &quot;</span>);<br>scanf_s(<span class="hljs-string">&quot;%s&quot;</span>, name, <span class="hljs-keyword">sizeof</span>(name));<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (name[i] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">islower</span>(name[i]))<br>name[i] = <span class="hljs-built_in">toupper</span>(name[i]);<br>res += name[i];<br>i++;<br>&#125;<br>res = res ^ <span class="hljs-number">0x5678</span> ^ <span class="hljs-number">0x1234</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Your Serials is %d.\n&quot;</span>, res);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>运行程序，任意输入名称，获取序列号，弹窗成功。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230815003026765.png" srcset="/img/load.gif" lazyload alt="输入名称与序列号"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230815003047382.png" srcset="/img/load.gif" lazyload alt="破解成功"></p><h2 id="Splish"><a href="#Splish" class="headerlink" title="Splish"></a>Splish</h2><h3 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h3><p>加载程序后，查看 <strong>API窗口</strong> ，发现是根据 <strong>GetwindowTextA</strong> 来获取输入，对该函数下断点后运行程序。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816011115839.png" srcset="/img/load.gif" lazyload alt="API窗口"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816011220089.png" srcset="/img/load.gif" lazyload alt="输入"></p><p>输入 <strong>Name</strong> 保存在 <strong>403236</strong> 处，<strong>Serial</strong> 保存在 <strong>403242</strong> 处。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816011409695.png" srcset="/img/load.gif" lazyload alt="中断"></p><p>继续单步运行程序，发现两次调用 <strong>GetWindowTextA</strong> 函数后，返回值( <strong>输入字符串长度</strong> )被存储在 <strong>403467</strong> 和 <strong>403463</strong> 处。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816011633202.png" srcset="/img/load.gif" lazyload alt="image-20230816011633202"></p><p>接下来分析对 <strong>输入Name</strong> 的处理，<strong>ESI</strong> 存储原始字符串地址，<strong>EDI</strong> 存储算法处理后的字符串地址，逐个字符依次处理。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816012004992.png" srcset="/img/load.gif" lazyload alt="Name算法分析"></p><blockquote><p>cdq指令用于将一个有符号的32位数扩展为64位数。具体来说，它将EAX寄存器中的32位有符号数扩展为EDX:EAX寄存器对中的64位有符号数。</p><p>idiv是汇编语言中的除法指令，用于执行有符号除法操作。</p><ul><li>商：商的结果存储在EAX寄存器中。</li><li>余数：余数的结果存储在EDX寄存器中</li></ul></blockquote><p>此处 <strong>cdq</strong> 指令用于将 <strong>EDX</strong> 置0，然后进行有符号位除法，此处对字符除以 <strong>0xA</strong> 后，商存储在 <strong>EAX</strong> 中，余数存储在 <strong>EDX</strong> 中， <strong>将余数与EBX的值进行异或运算后加2</strong>，然后将得到的 <strong>EDX的低位字节dl值</strong> 与 <strong>0xA</strong> 进行比较，如果大于，则 <strong>DL-0xA</strong> ，最后将 <strong>DL</strong> 的值存储在指定地点，依次进行下一个值得比较。</p><p>使用 <strong>IDA</strong> 对代码进行反编译后，对 <strong>name</strong> 执行的算法跟上述相同。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816014852568.png" srcset="/img/load.gif" lazyload alt="伪代码"></p><p>然后对序列号算法进行分析，对 <strong>Serial</strong> 也是逐字符处理，并将结果保存至 <strong>401669</strong> 处。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816014207285.png" srcset="/img/load.gif" lazyload alt="Serial算法分析"></p><p>同上，执行有符号位除法后， 商存储在 <strong>EAX</strong> 中，余数存储在 <strong>EDX</strong> 中，然后将 <strong>EDX中低字段DL的值</strong> 存储在指定地点，<strong>IDA</strong> 反编译结果如下。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816014904997.png" srcset="/img/load.gif" lazyload alt="伪代码"></p><p>然后对两次运算后得到的数据进行逐字符对比，如果一致则弹窗正确。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816015201713.png" srcset="/img/load.gif" lazyload alt="结果对比"></p><p>循环结束的条件是遍历完 <strong>处理后name</strong> 中的所有字符，所以其实要求 <strong>输入name的长度小于等于serial的长度</strong>， <strong>IDA</strong> 反编译结果如下。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816015530210.png" srcset="/img/load.gif" lazyload alt="反编译"></p><p>显然两次处理后得到的字符串并不相同，这里手动设置标志位，最后弹窗成功。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816015858578.png" srcset="/img/load.gif" lazyload alt="弹窗成功"></p><h3 id="注册机编写-1"><a href="#注册机编写-1" class="headerlink" title="注册机编写"></a>注册机编写</h3><h4 id="原理概述-1"><a href="#原理概述-1" class="headerlink" title="原理概述"></a>原理概述</h4><p>根据上述代码分析，我们可以对输入的 <strong>Name</strong> 进行计算得到十六进制的值，这个值与 <strong>Serial</strong> 计算得到的值相等就会弹窗成功，我们由这个值来推算 <strong>Serial</strong> ，因为这个值其实等于 <strong>Serial</strong> 算法运算后的余数部分，我们无法得知除数为多少，所以答案可能有多种，我这里只是对除数从1到10进行枚举，如果是 <strong>可打印字符</strong> 则输出。</p><h4 id="注册机-1"><a href="#注册机-1" class="headerlink" title="注册机"></a>注册机</h4><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-7vtoo4lli9jctd"></i><span>c</span><div class="collapse show" id="collapse-7vtoo4lli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;ctype.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">20</span>];<br><span class="hljs-type">char</span> serial[<span class="hljs-number">20</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Please input your name: &quot;</span>);<br>scanf_s(<span class="hljs-string">&quot;%s&quot;</span>, name, <span class="hljs-number">20</span>);<br><span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (name[i] != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>&#123;<br><span class="hljs-type">char</span> c = name[i];<br><span class="hljs-type">int</span> x = ((c % <span class="hljs-number">0xa</span>) ^ i) + <span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (x &gt;= <span class="hljs-number">0xa</span>)<br>x = x - <span class="hljs-number">0xa</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">10</span>; j++)<br>&#123;<br><span class="hljs-type">int</span> y = j * <span class="hljs-number">0xa</span> + x;<br><span class="hljs-keyword">if</span> (y &gt; <span class="hljs-number">32</span> &amp;&amp; y &lt;= <span class="hljs-number">126</span>)<br>&#123;<br>serial[i] = y;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>i++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Your serial may be : %s\n&quot;</span>, serial);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>运行程序，任意输入名称，获取序列号，弹窗成功。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/77d1b2e4/image-20230816024700378.png" srcset="/img/load.gif" lazyload alt="弹窗成功"></p>]]></content>
    
    
    <categories>
      
      <category>使用Ollydbg从零开始Cracking</category>
      
      <category>xdbg使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>菜鸡逆向</tag>
      
      <tag>xdbg基础使用</tag>
      
      <tag>序列号算法分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IDA Pro基础使用教程</title>
    <link href="/posts/e31f7c37/"/>
    <url>/posts/e31f7c37/</url>
    
    <content type="html"><![CDATA[<p>主要介绍IDA Pro工具的基本使用，以便能够在逆向工作中更加得心应手。</p><span id="more"></span><h3 id="IDA文件加载"><a href="#IDA文件加载" class="headerlink" title="IDA文件加载"></a>IDA文件加载</h3><p>当拖动文件进入 <strong>IDA</strong> 时，会出现一个加载对话框，<strong>IDA</strong> 会生成一个可能的文件类型列表，并在对话框顶部显示这个列表。<strong>Binary file</strong> 是这个列表的最后一个选项，它会一直显示，它是 <strong>IDA</strong> 加载无法识别的文件的默认选项。绝大多数情况下，默认选项提供的都是最佳的反汇编选项，对于二进制文件，<strong>IDA</strong> 不会进行任何初始反汇编。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811004152315.png" srcset="/img/load.gif" lazyload alt="文件加载"></p><h3 id="IDA数据库文件"><a href="#IDA数据库文件" class="headerlink" title="IDA数据库文件"></a>IDA数据库文件</h3><p><strong>IDA</strong> 加载文件时，会创建一个数据库，其组件分别保存在4个文件中，扩展名分别为 <strong>.id0、.id1、.nam、.til</strong>。当关闭项目时，这4个文件通常被存档，也可以选择将它们压缩成一个 <strong>IDB</strong> 文件，人们说到 <strong>IDA</strong> 数据库时实际上指的是 <strong>IDB</strong> 文件。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811005823276.png" srcset="/img/load.gif" lazyload alt="IDA关闭"></p><ul><li>Don’t pack database：不打包数据库，不创建 <strong>IDB</strong> 文件</li><li>Pack databse(Store)：打包数据库(存储)，创建 <strong>IDB</strong> 文件，4个数据库组件文件被删除</li><li>Pack database(Deflate)：打包数据库(压缩)，跟上面的区别是对 <strong>IDB</strong> 文件进行了压缩</li><li>Collect garbage：通常在磁盘空间不足时才选择这个</li><li>Don’t Save the database：相当于撤销或还原功能</li></ul><h3 id="IDA桌面"><a href="#IDA桌面" class="headerlink" title="IDA桌面"></a>IDA桌面</h3><p><strong>IDA</strong> 成功加载文件后，显示信息大致如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811011226201.png" srcset="/img/load.gif" lazyload alt="加载文件"></p><p><strong>概况导航栏：</strong> 导航带是被加载文件地址空间的线性视图。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811010924166.png" srcset="/img/load.gif" lazyload alt="导航带"></p><p><strong>反汇编视图：</strong> 它有两种不同的形式，图形视图和列表视图，使用 <strong>空格键</strong> 在图形视图和列表视图之间切换。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811011500912.png" srcset="/img/load.gif" lazyload alt="图形视图"></p><p><strong>输出窗口：</strong> 显示 <strong>IDA</strong> 输出的信息，输出窗口基本上等同于一个控制台输出设备。</p><p><strong>函数窗口：</strong> 默认是IDA显示窗口的最后一部分。</p><p>当输出窗口提示 <strong>The initial autoanalysis has been finished</strong> ，表示初步分析已完成，这时，你可以对数据库进行任意更改。</p><h3 id="IDA数据显示窗口"><a href="#IDA数据显示窗口" class="headerlink" title="IDA数据显示窗口"></a>IDA数据显示窗口</h3><p><strong>几乎所有的操作都有其对应的菜单项、热键和工具栏按钮，IDA的工具栏高度可配置。</strong></p><p>在 <strong>IDA</strong> 中，<strong>ESC</strong> 是一个非常有用的快捷键，它在反汇编窗口是非常有用，相当于浏览器中的后退按钮。</p><h4 id="反汇编窗口"><a href="#反汇编窗口" class="headerlink" title="反汇编窗口"></a>反汇编窗口</h4><p><strong>绿色箭头表示Yes，红色箭头表示No，只有一个后继块的基本块会使用蓝色箭头指向下一个即将执行的块。</strong></p><p>在图形模式下， <strong>IDA一次显示一个函数</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811012647810.png" srcset="/img/load.gif" lazyload alt="图形视图"></p><p><strong>文本视图</strong>：通常虚拟地址以 <strong>[区域名称]:[虚拟地址]</strong> 这种格式显示。左边部分叫做 <strong>箭头窗口</strong>： <strong>实现箭头表示非条件跳转，虚线箭头表示条件跳转</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811013604017.png" srcset="/img/load.gif" lazyload alt="文本视图"></p><p><strong>代码交叉引用</strong>，它表示另一个程序指令将控制权转交给交叉引用注释所在位置的指令。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811014041357.png" srcset="/img/load.gif" lazyload alt="代码交叉引用"></p><h4 id="函数窗口"><a href="#函数窗口" class="headerlink" title="函数窗口"></a>函数窗口</h4><p>用于列举 <strong>IDA</strong> 在数据库中识别到的 <strong>每一个函数</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811014256447.png" srcset="/img/load.gif" lazyload alt="函数窗口"></p><h4 id="十六进制窗口"><a href="#十六进制窗口" class="headerlink" title="十六进制窗口"></a>十六进制窗口</h4><p>如果一个反汇编窗口和一个十六进制窗口 <strong>同步</strong>，在一个窗口中滚动鼠标，另一个窗口也会滚动到同一虚拟地址处。有时候，十六进制窗口中显示的都是 <strong>??</strong> 号，表示 <strong>IDA</strong> 无法识别给定的虚拟地址范围内的值，如果程序包含一个BSS节，就会出现这种情况。<strong>bss节不占用文件的空间，但是加载器会扩展这一节，以适应程序的静态存储要求。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811015004528.png" srcset="/img/load.gif" lazyload alt="十六进制窗口"></p><h4 id="导出窗口"><a href="#导出窗口" class="headerlink" title="导出窗口"></a>导出窗口</h4><p><strong>导出窗口列出文件的入口点，这包括程序的执行入口点，以及任何由文件导出给其他文件使用的函数和变量。</strong> 导出的项目案 <strong>名称、虚拟地址和序数</strong> 排列，对于可执行文件，导出窗口中至少包含一个项目：<strong>程序的执行入口点</strong>，<strong>IDA</strong> 讲这个入口点取名为 <strong>start</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811020025185.png" srcset="/img/load.gif" lazyload alt="导出窗口"></p><h4 id="导入窗口"><a href="#导入窗口" class="headerlink" title="导入窗口"></a>导入窗口</h4><p><strong>导入窗口列出由被分析的二进制文件导入的所有函数。</strong> <strong>静态链接的二进制文件保存在外部依赖关系</strong>，因此不需要导入其他内容。</p><p>导入窗口每个条目列出一个导入项目的名称，以及包含该项目的库的名称。由于被导入的函数位于共享库中，窗口中的每个条目列出的地址相关导入表条目的虚拟地址。，双击条目，<strong>IDA</strong> 将跳转到条目对应地址处，而内存中显示内容为 **?? ?? ?? ??**。 <strong>因为IDA是一种静态分析工具，它无法获知程序在执行时会在这个内存输入什么地址。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811020740746.png" srcset="/img/load.gif" lazyload alt="导入表"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811020758335.png" srcset="/img/load.gif" lazyload alt="导入表条目地址"></p><p><strong>String窗口</strong></p><p><strong>String窗口显示从二进制文件中提取的一组字符串，以及每个字符串所在的地址。</strong></p><p>忽略指令&#x2F;数据定义：这个选项的作用是确保 <strong>IDA</strong> 会在所有可能发现字符串的地方扫描各种类型的字符串。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811021410454.png" srcset="/img/load.gif" lazyload alt="String窗口"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811022048308.png" srcset="/img/load.gif" lazyload alt="忽略指令/数据定义"></p><h4 id="Names窗口"><a href="#Names窗口" class="headerlink" title="Names窗口"></a>Names窗口</h4><p><strong>名称是对一个程序虚拟地址的符号描述。</strong></p><p>如果一个位置在程序符号表中命名，<strong>IDA</strong> 将采用该名称，如果没有名称，<strong>则IDA会生成一个默认的名称</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230811022628217.png" srcset="/img/load.gif" lazyload alt="Names窗口"></p><p>在 <strong>IDA</strong> 给某个位置命名时，它会使用 <strong>该位置的虚拟地址和一个表示该位置的类型</strong> 的前缀进行命名，常见的前缀包括下面这些：</p><ul><li>sub_xxxxxx：地址xxxxxx处的子例程</li><li>loc_xxxxxx：地址xxxxxx处的一个指令</li><li>byte_xxxxxx：位置xxxxxx处的8位数据</li><li>word_xxxxxx：位置xxxxxx处的16位数据</li><li>dword_xxxxxx：位置xxxxxx处的32位数据</li><li>unk_xxxxxx：位置xxxxxx处的大小未知的数据</li></ul><p><strong>loc和sub指令区别</strong>：loc指令相当于一处标记，一般都是跳转到loc处，如：jmp loc_xxxxxx；而sub指令相当于一个函数，一般是进行函数调用，如：call sub_xxxxxx。</p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>记住大量地址并非易事，这促使早期的程序员给他们希望引用的程序位置分配符号名称，<strong>给符号分配名称，与给程序操作码分配助记指令名称并无不同</strong>。</p><h4 id="交叉引用"><a href="#交叉引用" class="headerlink" title="交叉引用"></a>交叉引用</h4><p><strong>IDA</strong> 的交叉引用通常简称为 <strong>XREF</strong> ，<strong>IDA</strong> 中有两类基本的交叉引用：<strong>代码交叉引用</strong> 和 <strong>数据交叉引用</strong> ，所有的引用的都是在 <strong>一个地址引用另一个地址</strong> 。</p><p>如下是一个交叉引用，地址中总有一个上行或下行箭头，表示 <strong>引用位置的相对方向</strong> ，由函数调用导致的交叉引用使用后缀 <strong>p</strong> ，跳转交叉引用使用后缀 <strong>j</strong>。下图中下行箭头表示  <strong>.text:004011E6</strong> 地址比当前行地址高，需要向下才能到达该地址。 </p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813010358980.png" srcset="/img/load.gif" lazyload alt="代码交叉引用"></p><p><strong>数据交叉引用</strong> 用于跟踪二进制文件访问数据的方式。<strong>IDA</strong> 中最常用的三种数据交叉引用分别用于表示某个位置何时被 <strong>读取</strong>、何时被 <strong>写入</strong> 以及何时被 <strong>引用</strong> 。</p><p><strong>后缀r</strong> 表示读取交叉引用，<strong>后缀w</strong> 表示写入交叉引用，<strong>后缀o</strong> 表示偏移量交叉引用，它表示引用的是某个位置的地址而不是内容。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813011728966.png" srcset="/img/load.gif" lazyload alt="数据交叉引用"></p><p>双击 <strong>sub_401000+1E</strong> 处交叉引用，可以看到引用的为该处地址 <strong>offset dword_402004</strong>，而非内容。通常，代码或数据中的 <strong>指针</strong> 操作会导致偏移量交叉引用，例如：数组访问操作通常在数组的起始地址上加一个偏移量来实现。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813012039296.png" srcset="/img/load.gif" lazyload alt="偏移量交叉引用"></p><p><strong>跳转到地址</strong></p><p>使用 <strong>Jump&gt;Jump to Address</strong> 命令或者使用快捷键 <strong>G</strong> 快速导航到指定位置，使用快捷键 <strong>ESC</strong> 可立即跳转到当前位置的上一个位置。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813012800389.png" srcset="/img/load.gif" lazyload alt="快捷键G"></p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p><strong>编译器通过栈帧使得对函数参数和局部变量分配和释放的过程对程序员透明。</strong></p><figure class="highlight plaintext"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-fccd9ylli9jctd"></i><span>assembly</span><div class="collapse show" id="collapse-fccd9ylli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push ebp<br>mov  ebp，esp<br>sub  esp，76<br></code></pre></td></tr></table></div></figure><p>如果希望 <strong>EBP</strong> 作为栈指针，那么在修改它之前，必须保存 <strong>EBP</strong> 的当前值，并且在返回调用方时恢复 <strong>EBP</strong> 的值，局部变量的空间在 <strong>sub</strong> 处分配。</p><p><strong>使用一个专用的栈指针，所有变量相对于栈指针寄存器的偏移量都可以计算出来，许多时候，正偏移量用于访问函数参数，而负偏移量用于访问局部变量。</strong></p><p>典型的 <strong>尾声</strong> 代码：恢复调用方的栈指针。</p><figure class="highlight plaintext"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-yd7n7qlli9jctd"></i><span>assembly</span><div class="collapse show" id="collapse-yd7n7qlli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov esp,ebp<br>pop ebp<br>ret<br></code></pre></td></tr></table></div></figure><p>栈帧是一个 <strong>运行时概念</strong> ，没有 <strong>栈</strong> 和 <strong>运行中</strong> 的程序，栈帧就不可能存在。</p><p>下面这片代码中， <strong>IDA</strong> 认为这个函数使用 <strong>EBP</strong> 寄存器作为栈指针，变量处表明 <strong>IDA</strong> 提供了一个 <strong>摘要栈视图</strong> ，列出了 <strong>栈帧内直接被引用的每一个变量，以及变量的大小和他们与栈指针的偏移距离。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813020138237.png" srcset="/img/load.gif" lazyload alt="摘要栈视图"></p><p>局部变量以 <strong>var_</strong> 为前缀，函数参数以 <strong>arg_</strong> 为前缀，<strong>IDA只会为那些在函数中直接引用的栈变量自动生成名称。</strong></p><p><strong>除了摘要栈视图外，IDA还提供了一个详细栈帧视图</strong>，这种视图会显示一个栈帧所分配道德每个字节。显示的两个特殊值分别为 <strong>s</strong> 和 <strong>r</strong>，表示被保存的返回地址 <strong>r</strong> 和 被保存的寄存器值 **(s，在本例中，s仅代表EBP)**。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813021210966.png" srcset="/img/load.gif" lazyload alt="栈帧视图"></p><h3 id="搜索数据库"><a href="#搜索数据库" class="headerlink" title="搜索数据库"></a>搜索数据库</h3><h4 id="文本搜索"><a href="#文本搜索" class="headerlink" title="文本搜索"></a>文本搜索</h4><p><strong>IDA文本搜索相当于对反汇编窗口进行子字符串搜索，通过search&gt;Text(alt+t)启动命令搜索</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813022103868.png" srcset="/img/load.gif" lazyload alt="文本搜索"></p><h4 id="二进制搜索"><a href="#二进制搜索" class="headerlink" title="二进制搜索"></a>二进制搜索</h4><p><strong>使用search&gt;sequence of bytes(alt+b)即可启动二进制搜索</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813022524275.png" srcset="/img/load.gif" lazyload alt="二进制搜索"></p><h3 id="名称和命名"><a href="#名称和命名" class="headerlink" title="名称和命名"></a>名称和命名</h3><p>在分析一个程序时，操作反汇编代码清单最常用的一个方法，是将默认名称更改为更有意义的名称。要更改一个名称，只需单击需要修改的名称，并使用 <strong>N</strong> 键打开更名对话框，或者右键选择 <strong>Rename</strong> 选项。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813163735795.png" srcset="/img/load.gif" lazyload alt="Rename"></p><p>栈变量有关的名称是反汇编清单中最简单的名称，它们 <strong>与特定的虚拟地址无关</strong> ，因而从未出现在名称窗口中。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813164014444.png" srcset="/img/load.gif" lazyload alt="栈变量重命名"></p><p>输入框中输入 <strong>空白名称</strong> ，将生成默认的名称。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>绝大多数 <strong>IDA注释</strong> 以分号为前缀，表示这一行分号以后的部分都属于注释。</p><h4 id="常规注释"><a href="#常规注释" class="headerlink" title="常规注释"></a>常规注释</h4><p>常规注释位于现有汇编代码的 <strong>尾部</strong>，使用 <strong>:</strong> 热键，可以打开 <strong>输入注释</strong> 对话框，常规注释可以跨越多行。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813171352618.png" srcset="/img/load.gif" lazyload alt="常规注释"></p><h4 id="可重复注释"><a href="#可重复注释" class="headerlink" title="可重复注释"></a>可重复注释</h4><p>可重复注释的行为与交叉引用的概念有关，热键为 <strong>;</strong> ，</p><h4 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h4><p>通过函数注释，可以为函数的反汇编代码清单顶部显示的注释分组。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/e31f7c37/image-20230813172357843.png" srcset="/img/load.gif" lazyload alt="函数注释"></p>]]></content>
    
    
    <categories>
      
      <category>逆向工具</category>
      
      <category>IDA使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>IDA pro使用教程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序员的自我修养--一</title>
    <link href="/posts/a504920f/"/>
    <url>/posts/a504920f/</url>
    
    <content type="html"><![CDATA[<p>对于平常的应用开发，我们很少需要关注编译和链接过程，IDE一般都将这一过程帮我们完成，通常将这种编译和链接合并到一起的过程称为 <strong>构建</strong> ，本文特意来探讨软件运行背后的原理。</p><span id="more"></span><div class="note note-danger">            <p>实践是检验真理的唯一标准</p>          </div><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>以 <strong>helloword</strong> 程序为例，代码如下：</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-tynjivlli9jcte"></i><span>c</span><div class="collapse show" id="collapse-tynjivlli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// hello.c</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world.\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></div></figure><p>当对 <strong>hello.c</strong> 进行构建时，<strong>IDE</strong> 帮我们做了以下四件事：<strong>预处理、编译、汇编、链接。</strong></p><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><blockquote><p>预处理过程主要处理那些源代码文件中以 <strong>“#“</strong> 开始的预编译指令：例如将所有的 <strong>#define</strong> 宏定义展开， <strong>#include</strong> 指令所包含的文件插入到该预编译指令的位置、删除所有注释等。</p></blockquote><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-3alrkalli9jcte"></i><span>bash</span><div class="collapse show" id="collapse-3alrkalli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 预处理<br>gcc -E hello.c -o hello.i<br></code></pre></td></tr></table></div></figure><p>执行完该指令后，生成预处理后的 <strong>hello.i</strong> 文件，部分文件内容如下：</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-mvlccelli9jcte"></i><span>C</span><div class="collapse show" id="collapse-mvlccelli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">// hello.i 部分文件内容</span><br>部分文件内容已省略<br>...<br>  __attribute__ ((__dllimport__)) <span class="hljs-type">int</span> __attribute__((__cdecl__)) _snwscanf_l(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *_Src,<span class="hljs-type">size_t</span> _MaxCount,<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *_Format,<span class="hljs-type">_locale_t</span> _Locale,...);<br>  __attribute__ ((__dllimport__)) <span class="hljs-type">int</span> __attribute__((__cdecl__)) _wscanf_l(<span class="hljs-type">const</span> <span class="hljs-type">wchar_t</span> *_Format,<span class="hljs-type">_locale_t</span> _Locale,...);<br><br>  __attribute__ ((__dllimport__)) <span class="hljs-type">size_t</span> __attribute__((__cdecl__)) _fread_nolock_s(<span class="hljs-type">void</span> *_DstBuf,<span class="hljs-type">size_t</span> _DstSize,<span class="hljs-type">size_t</span> _ElementSize,<span class="hljs-type">size_t</span> _Count,FILE *_File);<br># <span class="hljs-number">1398</span> <span class="hljs-string">&quot;C:/Program Files/Mingw-w64/x86_64-8.1.0-release-win32-seh-rt_v6-rev0/mingw64/x86_64-w64-mingw32/include/stdio.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br><br># <span class="hljs-number">1</span> <span class="hljs-string">&quot;C:/Program Files/Mingw-w64/x86_64-8.1.0-release-win32-seh-rt_v6-rev0/mingw64/x86_64-w64-mingw32/include/_mingw_print_pop.h&quot;</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br># <span class="hljs-number">1400</span> <span class="hljs-string">&quot;C:/Program Files/Mingw-w64/x86_64-8.1.0-release-win32-seh-rt_v6-rev0/mingw64/x86_64-w64-mingw32/include/stdio.h&quot;</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span><br># <span class="hljs-number">2</span> <span class="hljs-string">&quot;.\\hello.c&quot;</span> <span class="hljs-number">2</span><br><br># <span class="hljs-number">2</span> <span class="hljs-string">&quot;.\\hello.c&quot;</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello world.\n&quot;</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></div></figure><p>可以发现，程序中 <strong>#include</strong> 指令已经在预处理阶段被替换为其包含的文件内容。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><blockquote><p>编译过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化，然后产生相应的 <strong>汇编代码</strong> 文件。</p></blockquote><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-aebqyklli9jcte"></i><span>bash</span><div class="collapse show" id="collapse-aebqyklli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 编译<br>gcc -S hello.i -o hello.s<br></code></pre></td></tr></table></div></figure><p>生成目标文件 <strong>hello.s</strong> ，内容如下：</p><figure class="highlight plaintext"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-cf0kyflli9jcte"></i><span>assembly</span><div class="collapse show" id="collapse-cf0kyflli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs assembly">// hello.s 文件内容<br>.file&quot;hello.c&quot;<br>.text<br>.def__main;.scl2;.type32;.endef<br>.section .rdata,&quot;dr&quot;<br>.LC0:<br>.ascii &quot;Hello world.\0&quot;<br>.text<br>.globlmain<br>.defmain;.scl2;.type32;.endef<br>.seh_procmain<br>main:<br>pushq%rbp<br>.seh_pushreg%rbp<br>movq%rsp, %rbp<br>.seh_setframe%rbp, 0<br>subq$32, %rsp<br>.seh_stackalloc32<br>.seh_endprologue<br>call__main<br>leaq.LC0(%rip), %rcx<br>callputs<br>movl$0, %eax<br>addq$32, %rsp<br>popq%rbp<br>ret<br>.seh_endproc<br>.ident&quot;GCC: (x86_64-win32-seh-rev0, Built by MinGW-W64 project) 8.1.0&quot;<br>.defputs;.scl2;.type32;.endef<br><br></code></pre></td></tr></table></div></figure><p>这里可以看到生成的汇编格式与我们平常见到的 <strong>Intel汇编</strong> 语法有所不同，主要取决于使用的工具和平台，<strong>GCC编译器使用了 AT&amp;T&#x2F;UNIX 汇编语法</strong>。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><blockquote><p>汇编器是将汇编代码转变为机器可以执行的指令，每一个汇编语句几乎都对应一条机器指令。</p></blockquote><p>源代码文件经过预处理、编译和汇编后生成 <strong>目标文件</strong>。</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-p0ibfalli9jcte"></i><span>bash</span><div class="collapse show" id="collapse-p0ibfalli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 汇编<br>gcc -c hello.s -o hello.o<br></code></pre></td></tr></table></div></figure><p>目标文件为<strong>二进制文件</strong>，可以使用 <strong>file、objdump、hexdump</strong>来查看该文件信息：</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-339tg4lli9jcte"></i><span>bash</span><div class="collapse show" id="collapse-339tg4lli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$:file hello.o<br>hello.o: Intel amd64 COFF object file, no line number info, not stripped, 7 sections, symbol offset=0x200, 20 symbols, 1st section name <span class="hljs-string">&quot;.text&quot;</span><br></code></pre></td></tr></table></div></figure><p>汇编之后的所有的全局变量以及函数的入口地址都被暂时设置为 <strong>0</strong> ，不能直接使用，需要下一个步骤， 链接。</p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><blockquote><p>目标代码中有变量定义在其他模块，该怎么办？事实上，定义其他模块的全局变量和函数在最终运行时的绝对地址都要在最终链接时才能确定。链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。</p></blockquote><p>链接过程主要包括了 <strong>地址和空间分配、符号决议和重定位</strong> 等步骤。</p><p>假设有个全局变量叫 <strong>var</strong> ，它在目标文件 <strong>A</strong> 里面，我们要在目标文件 <strong>B</strong> 里面访问这个全局变量，目标文件 <strong>B</strong> 里面有这样一条指令：</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-tnib3mlli9jcte"></i><span>c</span><div class="collapse show" id="collapse-tnib3mlli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 相当于C语言中的 var=42</span><br>movl $<span class="hljs-number">0x2a</span>,var<br></code></pre></td></tr></table></div></figure><p>我们这里来实践查看一下效果：</p><figure class="highlight plaintext"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-t54kcelli9jcte"></i><span>assembly</span><div class="collapse show" id="collapse-t54kcelli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs assembly">// vim test.c  extern指明var为外部引用<br>#include&lt;stdio.h&gt;<br>extern int var;<br>int main(void)<br>&#123;<br>        var=42;<br>        return 0;<br>&#125;<br><br>// 将源代码编译成目标文件<br>$:gcc -E test.c -o test.i<br>$:gcc -S test.i -o test.s<br>$:gcc -c test.s -o test.o<br><br>// 使用objdump来查看反汇编代码<br>$:objdump -d test.o<br>Disassembly of section .text:<br><br>0000000000000000 &lt;main&gt;:<br>   0:   f3 0f 1e fa             endbr64<br>   4:   55                      push   %rbp<br>   5:   48 89 e5                mov    %rsp,%rbp<br>   8:   c7 05 00 00 00 00 2a    movl   $0x2a,0x0(%rip)        # 12 &lt;main+0x12&gt;<br>   f:   00 00 00<br>  12:   b8 00 00 00 00          mov    $0x0,%eax<br>  17:   5d                      pop    %rbp<br>  18:   c3                      ret<br></code></pre></td></tr></table></div></figure><p>可以看到，指令 <strong>movl $0x2a,var</strong> 对应的机器码为 <strong>c7 05 00 00 00 00 2a</strong> ，由于编译目标文件时候，编译器并不知道变量 <strong>var</strong> 的地址，所以将这条 <strong>mov</strong> 指令的地址置为0，等待 <strong>链接器将目标文件A和目标文件B链接起来的时候再将其修正</strong>，这个修正的过程也叫做 <strong>重定位</strong>。</p><h3 id="目标文件格式"><a href="#目标文件格式" class="headerlink" title="目标文件格式"></a>目标文件格式</h3><p>目标文件从结构上讲，它是已经编译后的可执行文件格式，只是还没有经过链接的过程，其中可能 <strong>有些符号或有些地址还没有被调整</strong>。</p><p>常见的按照 <strong>可执行文件格式</strong> 存储的文件，他们都是 <strong>COFF(Common file format)</strong> 格式的变种：</p><ul><li>Windows下的 <strong>PE(Portable Executable)</strong> 文件</li><li>Linux下的 <strong>ELF(Executable Linkable Format)</strong> 文件</li><li>动态链接库 <strong>DLL(Dynamic Linking Library)</strong></li><li>静态链接库 <strong>LIB(Static Linking Library)</strong></li></ul><p><strong>目标文件跟可执行文件的内容和结构很相似，所以一般跟可执行文件格式一起采用一种格式存储。</strong></p><h4 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h4><p>目标文件的内容至少有编译后的机器指令 <strong>代码、数据</strong>，除了这些，还包括链接时所必需的一些信息，比如 <strong>符号表、调试信息、字符串</strong> 等。 <strong>一般目标文件将这些信息按不同的属性，以 “节” 的形式存储，有时也叫 “段”，它们都表示一个一定长度的区域</strong>。</p><ul><li>代码段(<strong>.code 或 .text</strong>)：编译后的机器指令通常被放在代码段</li><li>数据段(<strong>.data</strong>)：已初始化全局变量和局部静态变量经常存放在数据段</li><li><strong>.bss</strong>：未初始化全局变量和局部静态变量</li></ul><p><strong>示例分析</strong></p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-wzp8aflli9jcte"></i><span>c</span><div class="collapse show" id="collapse-wzp8aflli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// simplesection.c</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">printf</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* format,...)</span>;<br><span class="hljs-type">int</span> global_init_var=<span class="hljs-number">84</span>;<br><span class="hljs-type">int</span> global_uninit_var;<br><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span><br>&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> static_var=<span class="hljs-number">85</span>;<br>        <span class="hljs-type">static</span> <span class="hljs-type">int</span> static_var2;<br>        <span class="hljs-type">int</span> a=<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> b;<br>        func1(static_var+static_var2+a+b);<br>        <span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-comment">// 生成目标文件 -c表示不链接</span><br>$: gcc -c simplesection.c -o simplesection.o<br>    <br><span class="hljs-comment">// 使用objdump查看节表信息</span><br>$: objdump -h simplesection.o<br> simplesection.o:     file format elf64-x86<span class="hljs-number">-64</span><br><br>Sections:<br>Idx Name          Size      VMA               LMA               File off  Algn<br>  <span class="hljs-number">0</span> .text         <span class="hljs-number">00000062</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000040</span>  <span class="hljs-number">2</span>**<span class="hljs-number">0</span><br>                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE<br>  <span class="hljs-number">1</span> .data         <span class="hljs-number">00000008</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000000</span>a4  <span class="hljs-number">2</span>**<span class="hljs-number">2</span><br>                  CONTENTS, ALLOC, LOAD, DATA<br>  <span class="hljs-number">2</span> .bss          <span class="hljs-number">00000008</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000000</span>ac  <span class="hljs-number">2</span>**<span class="hljs-number">2</span><br>                  ALLOC<br>  <span class="hljs-number">3</span> .rodata       <span class="hljs-number">00000004</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000000</span>ac  <span class="hljs-number">2</span>**<span class="hljs-number">0</span><br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  <span class="hljs-number">4</span> .comment      <span class="hljs-number">0000002</span>e  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000000b</span>0  <span class="hljs-number">2</span>**<span class="hljs-number">0</span><br>                  CONTENTS, READONLY<br>  <span class="hljs-number">5</span> .note.GNU-<span class="hljs-built_in">stack</span> <span class="hljs-number">00000000</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000000</span>de  <span class="hljs-number">2</span>**<span class="hljs-number">0</span><br>                  CONTENTS, READONLY<br>  <span class="hljs-number">6</span> .note.gnu.property <span class="hljs-number">00000020</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">000000e0</span>  <span class="hljs-number">2</span>**<span class="hljs-number">3</span><br>                  CONTENTS, ALLOC, LOAD, READONLY, DATA<br>  <span class="hljs-number">7</span> .eh_frame     <span class="hljs-number">00000058</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">0000000000000000</span>  <span class="hljs-number">00000100</span>  <span class="hljs-number">2</span>**<span class="hljs-number">3</span><br>                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, DATA<br></code></pre></td></tr></table></div></figure><p>可以看到，除了基本的代码段、数据段、BSS段外，还有好多其他的段，这里暂且不去深究。</p><h5 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h5><p>使用 <strong>objdump</strong> 来查看所有段的内容，可以看到  <strong>.text</strong> 段跟我们前面得到的长度相符合，对照下面的 <strong>反汇编结果</strong> ，可以很明显的看到， <strong>.text</strong> 段里面包含的正是源文件中两个函数 <strong>func1()</strong> 和 <strong>main()</strong> 指令。</p><figure class="highlight plaintext"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-htr0xplli9jcte"></i><span>assembly</span><div class="collapse show" id="collapse-htr0xplli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs assembly">// -s 十六进制打印所有段内容  -d 反汇编<br>$:objdump -s -d simplesection.o<br>simplesection.o:     file format elf64-x86-64<br><br>Contents of section .text:<br> 0000 f30f1efa 554889e5 4883ec10 897dfc8b  ....UH..H....&#125;..<br> 0010 45fc89c6 488d0500 00000048 89c7b800  E...H......H....<br> 0020 000000e8 00000000 90c9c3f3 0f1efa55  ...............U<br> 0030 4889e548 83ec10c7 45f80100 00008b15  H..H....E.......<br> 0040 00000000 8b050000 000001c2 8b45f801  .............E..<br> 0050 c28b45fc 01d089c7 e8000000 008b45f8  ..E...........E.<br> 0060 c9c3                                 ..<br>......<br>Disassembly of section .text:<br><br>0000000000000000 &lt;func1&gt;:<br>   0:   f3 0f 1e fa             endbr64<br>   4:   55                      push   %rbp<br>   5:   48 89 e5                mov    %rsp,%rbp<br>   8:   48 83 ec 10             sub    $0x10,%rsp<br>   c:   89 7d fc                mov    %edi,-0x4(%rbp)<br>   f:   8b 45 fc                mov    -0x4(%rbp),%eax<br>  12:   89 c6                   mov    %eax,%esi<br>  14:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 1b &lt;func1+0x1b&gt;<br>  1b:   48 89 c7                mov    %rax,%rdi<br>  1e:   b8 00 00 00 00          mov    $0x0,%eax<br>  23:   e8 00 00 00 00          call   28 &lt;func1+0x28&gt;<br>  28:   90                      nop<br>  29:   c9                      leave<br>  2a:   c3                      ret<br><br>000000000000002b &lt;main&gt;:<br>  2b:   f3 0f 1e fa             endbr64<br>  2f:   55                      push   %rbp<br>  30:   48 89 e5                mov    %rsp,%rbp<br>  33:   48 83 ec 10             sub    $0x10,%rsp<br>  37:   c7 45 f8 01 00 00 00    movl   $0x1,-0x8(%rbp)<br>  3e:   8b 15 00 00 00 00       mov    0x0(%rip),%edx        # 44 &lt;main+0x19&gt;<br>  44:   8b 05 00 00 00 00       mov    0x0(%rip),%eax        # 4a &lt;main+0x1f&gt;<br>  4a:   01 c2                   add    %eax,%edx<br>  4c:   8b 45 f8                mov    -0x8(%rbp),%eax<br>  4f:   01 c2                   add    %eax,%edx<br>  51:   8b 45 fc                mov    -0x4(%rbp),%eax<br>  54:   01 d0                   add    %edx,%eax<br>  56:   89 c7                   mov    %eax,%edi<br>  58:   e8 00 00 00 00          call   5d &lt;main+0x32&gt;<br>  5d:   8b 45 f8                mov    -0x8(%rbp),%eax<br>  60:   c9                      leave<br>  61:   c3                      ret<br></code></pre></td></tr></table></div></figure><h5 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h5><p><strong>.data</strong> 段保存了已经初始化的全局变量和局部静态变量，源代码中共有两个这样的变量，分别为 <strong>global_init_var</strong> 与 <strong>static_var</strong>。</p><figure class="highlight jboss-cli"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-mileiclli9jcte"></i><span>jboss-cli</span><div class="collapse show" id="collapse-mileiclli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">//</span> <span class="hljs-string">.data</span>段和<span class="hljs-string">.rodata</span>段<br>Contents of section <span class="hljs-string">.data</span>:<br> 0000 54000000 55000000                    T.<span class="hljs-string">..U...</span><br>Contents of section <span class="hljs-string">.rodata</span>:<br> 0000 25640a00                             %d..<br></code></pre></td></tr></table></div></figure><p>可以看到 <strong>.data</strong> 段为8个字节，分别为 <strong>0x54、0x55</strong>，对应源代码中的静态变量。</p><p><strong>.rodata</strong> 段存放的是只读数据，一般是程序里面的只读变量(如const修饰的变量)和字符串常量。上述源程序在调用 <strong>printf</strong> 的时候，用到了一个字符串常量 <strong>“%d\n”</strong> ，它是一种只读数据，所以被放到了 <strong>.rodata</strong> 段，输出结果可以看到 <strong>.rodata</strong> 段的前四个字节刚好是这个字符串常量的ASCII字节序，最后以 <strong>\0</strong> 结尾。</p><p>有时候编译器也会把字符串常量放到 <strong>.data</strong> 段，而不是单独放在 <strong>.rodata</strong> 段。</p><h5 id="BSS段"><a href="#BSS段" class="headerlink" title="BSS段"></a>BSS段</h5><p><strong>.bss</strong> 段存放的是未初始化的全局变量和局部静态变量，上述源代码中 <strong>global_uninit_var</strong> 和 <strong>static_var2</strong>就是存放在 <strong>.bss</strong> 段。</p><p>未初始化的全局变量和局部静态变量默认值都为 <strong>0</strong> ，为他们空间并且保存数据 <strong>0</strong> 是没有必要的，所以 <strong>.bss 段并没有内容，在文件中也不占据磁盘空间</strong>，在可执行文件中，只会记录BSS段所需的内存大小信息，而不会存储实际的BSS数据。</p><figure class="highlight plaintext"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-c0j0jqlli9jcte"></i><span>assembly</span><div class="collapse show" id="collapse-c0j0jqlli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs assembly">// 查看符号表<br>$: objdump -t simplesection.o<br>simplesection.o:     file format elf64-x86-64<br><br>SYMBOL TABLE:<br>0000000000000000 l    df *ABS*  0000000000000000 simplesection.c<br>0000000000000000 l    d  .text  0000000000000000 .text<br>0000000000000000 l    d  .data  0000000000000000 .data<br>0000000000000000 l    d  .bss   0000000000000000 .bss<br>0000000000000000 l    d  .rodata        0000000000000000 .rodata<br>0000000000000004 l     O .data  0000000000000004 static_var.1<br>0000000000000004 l     O .bss   0000000000000004 static_var2.0<br>0000000000000000 g     O .data  0000000000000004 global_init_var<br>0000000000000000 g     O .bss   0000000000000004 global_uninit_var<br>0000000000000000 g     F .text  000000000000002b func1<br>0000000000000000         *UND*  0000000000000000 printf<br>000000000000002b g     F .text  0000000000000037 main<br></code></pre></td></tr></table></div></figure><p>查看目标文件的符号表，可以看到上述两个变量 <strong>global_uninit_var、static_var2</strong> 存储在 <strong>.bss</strong> 段。 </p><h3 id="ELF文件结构"><a href="#ELF文件结构" class="headerlink" title="ELF文件结构"></a>ELF文件结构</h3><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/a504920f/elf-file-format.png" srcset="/img/load.gif" lazyload alt="ELF文件结构"></p><h4 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h4><p>对照ELF的文件结构，查看目标文件的文件头：</p><figure class="highlight sh"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-uwtuovlli9jcte"></i><span>sh</span><div class="collapse show" id="collapse-uwtuovlli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs sh">// 查看目标文件Header<br>$: readelf -h simplesection.o<br>ELF Header:<br>  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00<br>  Class:                             ELF64<br>  Data:                              2<span class="hljs-string">&#x27;s complement, little endian</span><br><span class="hljs-string">  Version:                           1 (current)</span><br><span class="hljs-string">  OS/ABI:                            UNIX - System V</span><br><span class="hljs-string">  ABI Version:                       0</span><br><span class="hljs-string">  Type:                              REL (Relocatable file)</span><br><span class="hljs-string">  Machine:                           Advanced Micro Devices X86-64</span><br><span class="hljs-string">  Version:                           0x1</span><br><span class="hljs-string">  Entry point address:               0x0</span><br><span class="hljs-string">  Start of program headers:          0 (bytes into file)</span><br><span class="hljs-string">  Start of section headers:          1032 (bytes into file)//段表的起始地址，也就是偏移</span><br><span class="hljs-string">  Flags:                             0x0</span><br><span class="hljs-string">  Size of this header:               64 (bytes)</span><br><span class="hljs-string">  Size of program headers:           0 (bytes)</span><br><span class="hljs-string">  Number of program headers:         0</span><br><span class="hljs-string">  Size of section headers:           64 (bytes)</span><br><span class="hljs-string">  Number of section headers:         14// 段的数量,可以用readelf -S 查看所有段</span><br><span class="hljs-string">  Section header string table index: 13</span><br></code></pre></td></tr></table></div></figure><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><p>在文件头中，已经看到，段表的偏移地址为1032，对应的十六进制为 <strong>0x408</strong>，查看段表信息：</p><figure class="highlight tap"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-kp53m8lli9jcte"></i><span>tap</span><div class="collapse show" id="collapse-kp53m8lli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs tap">$: readelf -S simplesection.o<br>There are<span class="hljs-number"> 14 </span>section headers, starting at offset 0x408:<br><br>Section Headers:<br>  [Nr] Name              Type             Address           Offset<br>       Size              EntSize          Flags  Link  Info  Align<br>  [ 0]                   NULL            <span class="hljs-number"> 0000000000000000 </span> 00000000//第一个元素是无效的段描述符，类型为NULL<br>      <span class="hljs-number"> 0000000000000000 </span><span class="hljs-number"> 0000000000000000 </span>         <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    0<br>  [ 1] .text             PROGBITS        <span class="hljs-number"> 0000000000000000 </span> 00000040<br>      <span class="hljs-number"> 0000000000000062 </span><span class="hljs-number"> 0000000000000000 </span> AX      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>  [ 2] .rela.text        RELA            <span class="hljs-number"> 0000000000000000 </span> 000002e8//重定位表<br>      <span class="hljs-number"> 0000000000000078 </span><span class="hljs-number"> 0000000000000018 </span>  I     <span class="hljs-number"> 11 </span>   <span class="hljs-number"> 1 </span>    8<br>  [ 3] .data             PROGBITS        <span class="hljs-number"> 0000000000000000 </span> 000000a4<br>      <span class="hljs-number"> 0000000000000008 </span><span class="hljs-number"> 0000000000000000 </span> WA      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    4<br>  [ 4] .bss              NOBITS          <span class="hljs-number"> 0000000000000000 </span> 000000ac<br>      <span class="hljs-number"> 0000000000000008 </span><span class="hljs-number"> 0000000000000000 </span> WA      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    4<br>  [ 5] .rodata           PROGBITS        <span class="hljs-number"> 0000000000000000 </span> 000000ac<br>      <span class="hljs-number"> 0000000000000004 </span><span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>  [ 6] .comment          PROGBITS        <span class="hljs-number"> 0000000000000000 </span> 000000b0<br>      <span class="hljs-number"> 0000000000000027 </span><span class="hljs-number"> 0000000000000001 </span> MS      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>  [ 7] .note.GNU-stack   PROGBITS        <span class="hljs-number"> 0000000000000000 </span> 000000d7<br>      <span class="hljs-number"> 0000000000000000 </span><span class="hljs-number"> 0000000000000000 </span>         <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>  [ 8] .note.gnu.pr[...] NOTE            <span class="hljs-number"> 0000000000000000 </span> 000000d8<br>      <span class="hljs-number"> 0000000000000020 </span><span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    8<br>  [ 9] .eh_frame         PROGBITS        <span class="hljs-number"> 0000000000000000 </span> 000000f8<br>      <span class="hljs-number"> 0000000000000058 </span><span class="hljs-number"> 0000000000000000 </span>  A      <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    8<br>  [10] .rela.eh_frame    RELA            <span class="hljs-number"> 0000000000000000 </span> 00000360<br>      <span class="hljs-number"> 0000000000000030 </span><span class="hljs-number"> 0000000000000018 </span>  I     <span class="hljs-number"> 11 </span>   <span class="hljs-number"> 9 </span>    8<br>  [11] .symtab           SYMTAB          <span class="hljs-number"> 0000000000000000 </span> 00000150<br>      <span class="hljs-number"> 0000000000000138 </span><span class="hljs-number"> 0000000000000018 </span>        <span class="hljs-number"> 12 </span>   <span class="hljs-number"> 8 </span>    8<br>  [12] .strtab           STRTAB          <span class="hljs-number"> 0000000000000000 </span> 00000288<br>      <span class="hljs-number"> 0000000000000060 </span><span class="hljs-number"> 0000000000000000 </span>         <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>  [13] .shstrtab         STRTAB          <span class="hljs-number"> 0000000000000000 </span> 00000390<br>      <span class="hljs-number"> 0000000000000074 </span><span class="hljs-number"> 0000000000000000 </span>         <span class="hljs-number"> 0 </span>   <span class="hljs-number"> 0 </span>    1<br>Key to Flags:<br>  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),<br>  L (link order), O (extra OS processing required), G (group), T (TLS),<br>  C (compressed), x (unknown), o (OS specific), E (exclude),<br>  D (mbind), l (large), p (processor specific)<br></code></pre></td></tr></table></div></figure><p>我们在前面得到段表的其实偏移地址为 <strong>1032</strong>，每个段描述符的大小为 <strong>64</strong> ，共 <strong>14</strong> 个段描述符，可以计算段表结束地址为：<strong>1032+64*14&#x3D;0x788</strong>，也就是 <strong>simplesection.o</strong> 文件结束地址。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/a504920f/image-20230809010147023.png" srcset="/img/load.gif" lazyload alt="文件结束地址"></p><p>上述段表中，存在一个 <strong>.rela.text</strong> 段，他的类型为 <strong>RELA</strong>，表示它是一个重定位表。链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位，即代码段和数据段中对绝对地址引用的位置。</p><h4 id="链接的接口–符号"><a href="#链接的接口–符号" class="headerlink" title="链接的接口–符号"></a>链接的接口–符号</h4><p>在链接中，每个函数和变量统称为 <strong>符号</strong> ，函数名或变量名就是 <strong>符号名</strong> ，我们可以将符号看作是链接中的粘合剂，整个链接过程正是基于符号才能正确完成。</p><p>每一个目标文件都会有一个相应的 <strong>符号表</strong> ，表里面记录了目标文件中所用到的所有符号，每个定义的符号有一个对应的值，叫做 <strong>符号值</strong> ，对于变量和函数来说，<strong>符号值就是他们的地址</strong>。</p><p>符号的常见类型有以下几种：</p><ul><li>定义在本目标文件中的 <strong>全局符号</strong> ，可以被其他目标文件引用。例如：<strong>func1、main、global_init_var</strong></li><li>在本目标文件中引用的全局符号，却没有定义在本目标文件，一般叫做 <strong>外部符号</strong> 。例如：<strong>printf</strong></li><li><strong>段名</strong>，这种符号往往由编译器产生，它的值就是该段的起始地址。</li><li><strong>局部符号</strong>，这些符号对于链接过程没有作用，链接器也往往忽略它们。</li><li><strong>行号信息</strong></li></ul><p>最值得关注的是 <strong>全局符号</strong> 和 <strong>外部符号</strong> ，查看目标文件的符号结果：</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-urqqxllli9jcte"></i><span>bash</span><div class="collapse show" id="collapse-urqqxllli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 查看目标文件符号表 <br>$:nm simplesection.o<br>0000000000000000 T func1<br>0000000000000000 D global_init_var<br>0000000000000000 B global_uninit_var<br>000000000000002b T main<br>                 U <span class="hljs-built_in">printf</span>// U表示该符号是一个未定义的符号，需要在链接时从其他模块中解析<br>0000000000000004 d static_var.1<br>0000000000000004 b static_var2.0<br></code></pre></td></tr></table></div></figure><h5 id="ELF符号表结构"><a href="#ELF符号表结构" class="headerlink" title="ELF符号表结构"></a>ELF符号表结构</h5><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-ssqsqqlli9jcte"></i><span>c</span><div class="collapse show" id="collapse-ssqsqqlli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Symbol table entry.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  Elf32_Word    st_name;                <span class="hljs-comment">/* Symbol name (string tbl index) */</span><br>  Elf32_Addr    st_value;               <span class="hljs-comment">/* Symbol value */</span><br>  Elf32_Word    st_size;                <span class="hljs-comment">/* Symbol size */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_info;                <span class="hljs-comment">/* Symbol type and binding */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_other;               <span class="hljs-comment">/* Symbol visibility */</span><br>  Elf32_Section st_shndx;               <span class="hljs-comment">/* Section index */</span><br>&#125; Elf32_Sym;<br> <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  Elf64_Word    st_name;                <span class="hljs-comment">/* Symbol name (string tbl index) */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_info;                <span class="hljs-comment">/* Symbol type and binding */</span><br>  <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> st_other;               <span class="hljs-comment">/* Symbol visibility */</span><br>  Elf64_Section st_shndx;               <span class="hljs-comment">/* Section index */</span><br>  Elf64_Addr    st_value;               <span class="hljs-comment">/* Symbol value */</span><br>  Elf64_Xword   st_size;                <span class="hljs-comment">/* Symbol size */</span><br>&#125; Elf64_Sym;<br></code></pre></td></tr></table></div></figure><p><strong>注：</strong> <strong>st_name</strong> 代表的是目标文件中 <strong>字符串表</strong> 中的一个索引值</p><p>查看目标文件的符号表：</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-kb4vmklli9jcte"></i><span>bash</span><div class="collapse show" id="collapse-kb4vmklli9jcte"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">$: readelf -s simplesection.o<br>Symbol table <span class="hljs-string">&#x27;.symtab&#x27;</span> contains 13 entries:<br>   Num:    Value          Size Type    Bind   Vis      Ndx Name<br>     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND<br>     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS simplesection.c<br>     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text<br>     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 .data<br>     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 .bss<br>     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata<br>     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_var.1<br>     7: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    4 static_var2.0<br>     8: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_init_var<br>     9: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    4 global_uninit_var<br>    10: 0000000000000000    43 FUNC    GLOBAL DEFAULT    1 func1<br>    11: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND <span class="hljs-built_in">printf</span><br>    12: 000000000000002b    55 FUNC    GLOBAL DEFAULT    1 main<br></code></pre></td></tr></table></div></figure><p>例： <strong>func1</strong> 和 <strong>main</strong> 函数都是定义在simplesection.c里面的，他们所在的位置都为代码段，所以 <strong>Ndx</strong> 为1，它们都是函数，类型为 <strong>STT_FUNC</strong> ，都是全局可见的，所以是 <strong>STB_GLOBAL</strong> ，<strong>Size</strong> 表示函数指令所占的字节数；<strong>Value</strong> 表示函数相对于代码段起始位置的偏移。</p>]]></content>
    
    
    <categories>
      
      <category>纸上得来终觉浅</category>
      
      <category>程序员的自我修养--链接、装载与库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浅析程序运行原理</tag>
      
      <tag>程序链接过程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ollydbg--硬编码序列号寻踪三</title>
    <link href="/posts/f0bbe23d/"/>
    <url>/posts/f0bbe23d/</url>
    
    <content type="html"><![CDATA[<p>继续增加难度，对程序序列号进行破解。–未完待续</p><span id="more"></span><h3 id="Splish"><a href="#Splish" class="headerlink" title="Splish"></a>Splish</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p><strong>OD</strong> 打开该程序，断在函数入口点 <strong>401000</strong> 处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803211731113.png" srcset="/img/load.gif" lazyload alt="OD载入"></p><p><strong>查找字符串</strong> ，发现成功输入正确序列号时字符串提示，双击来到引用字符串处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803212230713.png" srcset="/img/load.gif" lazyload alt="查找字符串"></p><p>可以看到通过 <strong>GetWindowTextA</strong> 来获取用户输入，用 <strong>MessageBoxA</strong> 来提示序列号正确性，对 <strong>GetWindowTextA</strong> 处下断点：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803212607309.png" srcset="/img/load.gif" lazyload alt="跳转到字符串引用处"></p><p>继续 <strong>查看当前模块API函数</strong> ，找到 <strong>GetWindowTextA</strong> 和 <strong>MessageBoxA</strong> 函数，对这两个函数下断点：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803211923320.png" srcset="/img/load.gif" lazyload alt="当前模块API函数"></p><p><strong>F9</strong> 一键运行程序到断点，用户输入保存至缓冲区 <strong>403215</strong> 处，然后将 <strong>“hardCoded“ 地址赋给eax，输入序列号地址赋给ebx</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803235313814.png" srcset="/img/load.gif" lazyload alt="获取用户输入"></p><p><strong>对两个字符串逐个字符比较，当字符为空时，跳出循环，如果字符不一致，弹窗错误。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803235828910.png" srcset="/img/load.gif" lazyload alt="比较过程分析"></p><p>由此处可以确定序列号为 <strong>HardCoded</strong> ，将<strong>EIP设置为40138C，跳出循环</strong>，此时继续往下执行，<strong>弹窗正确</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804000400469.png" srcset="/img/load.gif" lazyload alt="此处设置为新EIP"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804000437108.png" srcset="/img/load.gif" lazyload alt="弹窗正确"></p><h4 id="程序破解"><a href="#程序破解" class="headerlink" title="程序破解"></a>程序破解</h4><p>程序的判断逻辑：<strong>对输入的序列号与正确序列号逐字符进行比较，发现字符不同就弹窗错误，只有字符都相同，才会弹窗正确</strong>，知道了逻辑后，程序的破解就很简单了，破解方法有很多，这里只演示一种常规方法，将逐字符比较的判断语句 <strong>nop</strong> 掉即可：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804001023137.png" srcset="/img/load.gif" lazyload alt="程序破解"></p><p>保存修改，运行程序输入任意序列号，均可以弹窗正确！</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804001141116.png" srcset="/img/load.gif" lazyload alt="弹窗正确"></p><h3 id="SamBo"><a href="#SamBo" class="headerlink" title="SamBo"></a>SamBo</h3><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>用 <strong>OD</strong> 载入该程序，提示该程序可能被 <strong>加壳</strong> ，我们先不管它，尝试加载，程序断在入口点 <strong>4D4001</strong> 处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804004429485.png" srcset="/img/load.gif" lazyload alt="提示加壳"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804004456842.png" srcset="/img/load.gif" lazyload alt="OD载入"></p><p><strong>查看程序内存窗口（alt+M）</strong>，发现程序入口点所属区段起始地址为4D4000，大小为2000H，入口点 <strong>4d4001</strong> ，代码段开始于 <strong>401000</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804005102033.png" srcset="/img/load.gif" lazyload alt="内存窗口"></p><p>从当前入口点开始解密其他区段，然后会跳转到真正的入口点处，<strong>F9</strong> 执行程序。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804005359472.png" srcset="/img/load.gif" lazyload alt="程序窗口"></p><p>弹出Crackme窗口，等待输入序列号，<strong>表明该程序已经在内存中解密区段结束了，现在在执行代码段中的代码，我们在.text区段上设置一个内存访问断点，让程序执行代码段中的代码中断下来。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804005557395.png" srcset="/img/load.gif" lazyload alt="内存访问断点"></p><p>设置断点后，程序断在 <strong>45c85f</strong> 处，程序正在解密内存中的各种区段，我们手动分析一下源代码，<strong>鼠标右键–分析–分析代码</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804005730190.png" srcset="/img/load.gif" lazyload alt="分析代码"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804005949971.png" srcset="/img/load.gif" lazyload alt="分析代码"></p><p>可以看到分析后的代码，现在我们位于代码段，查看当前模块使用了哪些API函数，<strong>为什么刚刚程序加载时候不查看，因为当时查看模块使用的API的话是查看的壳所在模块使用的API函数</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010104736.png" srcset="/img/load.gif" lazyload alt="分析后的代码"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010241817.png" srcset="/img/load.gif" lazyload alt="API函数列表"></p><p>很不幸API函数列表中显示的是一些比较陌生的字符串，接下来尝试查看 <strong>全局字符串</strong> ，看看有没有有用信息，<strong>发现提示成功的字符串</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010459387.png" srcset="/img/load.gif" lazyload alt="全局字符串"></p><p>查看字符串引用地方，发现这里存在 <strong>比较指令和跳转指令，附近还有提示错误的代码块，但是并不是通过调用MessageBoxA函数来提示。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010700724.png" srcset="/img/load.gif" lazyload alt="字符串引用"></p><p>在 <strong>test指令</strong> 处设置断点，并清除之前设置的 <strong>内存断点</strong> ，然后运行程序，输入序列号。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010840952.png" srcset="/img/load.gif" lazyload alt="设置断点"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010936972.png" srcset="/img/load.gif" lazyload alt="删除内存断点"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011026150.png" srcset="/img/load.gif" lazyload alt="输入序列号"></p><p>程序断下来之后，继续单步执行，发现跳转实现，<strong>F9</strong> 继续运行，弹窗提示成功。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011302041.png" srcset="/img/load.gif" lazyload alt="戏耍弹窗"></p><p>点击确定，发现上一步弹窗是假的，只是<strong>戏耍</strong>我们。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011352103.png" srcset="/img/load.gif" lazyload alt="弹窗二"></p><p>再次输入序列号提交，程序依然断在 <strong>test指令</strong> 处，这次修改标志位尝试不跳转：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011610215.png" srcset="/img/load.gif" lazyload alt="修改标志位"></p><p>运行程序，弹窗成功！</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011641045.png" srcset="/img/load.gif" lazyload alt="弹窗成功"></p><p>得到结论：<strong>这个跳转是觉得序列号是否正确的关键跳转</strong> ，接下来分析一下跳转的具体代码：<strong>test指令前还存在一个call指令，我们这次把断点设置在call指令，查看一下堆栈情况</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011952145.png" srcset="/img/load.gif" lazyload alt="堆栈分析"></p><p><strong>堆栈中存在刚刚输入的序列号，数据窗口跟随定位到字符串，此时可以看到数据窗口中存在字符串 1556555 ，可能是正确序列号，我们对错误序列号设置内存访问断点，当错误序列号与正确序列号进行比较的话，就会断下来。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804012218874.png" srcset="/img/load.gif" lazyload alt="内存访问断点"></p><p><strong>F9</strong> 运行程序，如果 <strong>call</strong> 指令中有访问该内存，就会中断下来，实际运行发现中断下来了(文档教程中明确说明：不会中断下来， <strong>此处的call指令并没有对序列号进行对比</strong>)，目前没有搞清楚原因在哪里，也可能是太菜了，先暂停！</p>]]></content>
    
    
    <categories>
      
      <category>使用Ollydbg从零开始Cracking</category>
      
      <category>OD使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ollydbg基础使用</tag>
      
      <tag>硬编码寻踪</tag>
      
      <tag>菜鸡逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ollydbg--硬编码序列号寻踪二</title>
    <link href="/posts/b2e77430/"/>
    <url>/posts/b2e77430/</url>
    
    <content type="html"><![CDATA[<p>上一章节中已经讲了OD的一些常用基本操作，并尝试对两个简单的程序进行破解，本章节继续熟悉OD的操作，并增加难度，对两个相对难一点的程序序列号进行破解。</p><span id="more"></span><h3 id="示例一：mielecrackme1"><a href="#示例一：mielecrackme1" class="headerlink" title="示例一：mielecrackme1"></a>示例一：mielecrackme1</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>老规矩，打开OD加载程序，程序断在函数入口点(<strong>401000</strong>)处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801232749135.png" srcset="/img/load.gif" lazyload alt="OD加载程序"></p><p>使用 <strong>中文搜索引擎</strong> 查找全局字符串，发现大量字符串，有经验的话，对字符串进行分析，大概能猜测到序列号：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801232850239.png" srcset="/img/load.gif" lazyload alt="查找字符串"></p><p>无法确定具体序列号，查看 <strong>当前模块API函数列表（ctrl+n）</strong>，发现几个比较重要的API函数：<strong>GetWindowTextA</strong> 用于获取用户输入，<strong>lstrcmpA</strong> 用于字符串的比较，<strong>MessageBoxA</strong> 显示弹窗：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801233131850.png" srcset="/img/load.gif" lazyload alt="当前模块API函数列表"></p><p>根据上一章的经验，我们对 <strong>lstrcmpA</strong> 函数下断点，看看函数是如何进行比较的，<strong>F9</strong> 运行程序：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801233533768.png" srcset="/img/load.gif" lazyload alt="输入序列号"></p><p>程序断在 <strong>lstrcmpA</strong> 函数这里，查看堆栈窗口，发现两个字符串，一个为我们的输入，一个大概率为正确的序列号：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801233729491.png" srcset="/img/load.gif" lazyload alt="程序断在lstrcmpA入口"></p><p>对该函数进行分析，可以发现，<strong>两条mov指令其实就是将两个字符串地址存储在寄存器edx和ecx中</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801234320345.png" srcset="/img/load.gif" lazyload alt="lstrcmpA分析一"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801234651857.png" srcset="/img/load.gif" lazyload alt="lstrcmpA分析二"></p><p>具体API函数的细节我们不再分析，接下来执行到返回，继续单步执行 <strong>F7</strong> 跳转到主模块，发现 <strong>or指令和jnz跳转指令 ，判断返回的eax是否为0，如果不为0则跳转至错误弹窗</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801235135739.png" srcset="/img/load.gif" lazyload alt="判断EAX是否为0"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801235527313.png" srcset="/img/load.gif" lazyload alt="跳转实现，弹窗错误"></p><p><strong>F9</strong> 运行程序，弹窗错误：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801235644233.png" srcset="/img/load.gif" lazyload alt="弹窗错误"></p><p>接下来我们尝试一下输入正确的序列号 <strong>cannabis</strong> ，看看程序的执行过程：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801235822439.png" srcset="/img/load.gif" lazyload alt="输入正确序列号"></p><p>可以看到，当输入正确序列号时，<strong>lstrcmpA</strong> 函数执行过后 <strong>EAX的值为0</strong>，此时将跳转失败，弹窗正确：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801235954012.png" srcset="/img/load.gif" lazyload alt="EAX=0"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802000105776.png" srcset="/img/load.gif" lazyload alt="弹窗正确"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802000141188.png" srcset="/img/load.gif" lazyload alt="运行结果"></p><h4 id="程序破解"><a href="#程序破解" class="headerlink" title="程序破解"></a>程序破解</h4><p>程序的破解也很简单，知道了整个流程，只需将程序的跳转语句 <strong>nop</strong> 掉，不执行跳转即可：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802000401501.png" srcset="/img/load.gif" lazyload alt="nop掉跳转语句"></p><p>将文件保存后运行，输入任意字符串，破解成功：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802000559343.png" srcset="/img/load.gif" lazyload alt="破解成功"></p><p><strong>注：</strong> 此例中新增了个函数 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-lstrcmpa">lstrcmpA</a>，该函数对两个字符串进行比较，如果相等则返回0，在此例中，返回结果保存在 <strong>EAX</strong> 中，用 <strong>OR</strong> 判断 <strong>EAX</strong> 是否为0，若为0，则证明两个字符串相等。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802003105878.png" srcset="/img/load.gif" lazyload alt="lstrcmpa函数"></p><h3 id="示例二：crakmeeasy"><a href="#示例二：crakmeeasy" class="headerlink" title="示例二：crakmeeasy"></a>示例二：crakmeeasy</h3><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>使用 <strong>OD</strong> 载入该程序，程序断在函数入口点（<strong>4011F0</strong>）处：<br><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802200907261.png" srcset="/img/load.gif" lazyload alt="OD载入"></p><p><strong>查找全局字符串</strong>，发现一组神秘数字：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802201009416.png" srcset="/img/load.gif" lazyload alt="查找字符串"></p><p>仅凭数字是无法确定序列号的，<strong>查看该模块的API函数列表</strong> ，发现可能有关的API函数 <strong>GetDlgItemTextA</strong> 和 <strong>memset</strong> ，对 <strong>GetDlgItemTextA</strong> 函数下断点：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802201252164.png" srcset="/img/load.gif" lazyload alt="API函数列表"></p><p><strong>F9</strong> 运行程序，输入序列号 <strong>test1234</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802202234413.png" srcset="/img/load.gif" lazyload alt="输入序列号"></p><p>程序断在 <strong>GetDlgItemTextA</strong> 处，继续执行到返回，用户输入存储在 <strong>0FE3CB10</strong> 处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802202458948.png" srcset="/img/load.gif" lazyload alt="执行到返回"></p><p>继续 <strong>F7</strong> 单步执行程序返回到主模块，可以看到，下面两个API函数分别为 <strong>memset</strong> 和 <strong>strlen</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802202617459.png" srcset="/img/load.gif" lazyload alt="单步执行"></p><p>分析程序逻辑，<strong>EAX存储字符串 “10445678951” 的地址，当执行到lea指令时，该字符串的值都已经存储在堆栈处的位置</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802203256502.png" srcset="/img/load.gif" lazyload alt="程序分析"></p><p>接下来调用 <strong>memset</strong> 函数，该函数有三个参数 <strong>(n,c,s)</strong>:</p><blockquote><p>s： 待填充的内存单元的起始地址</p><p>n：需要填充的字节数</p><p>c：待填充的值</p></blockquote><p><strong>F8</strong> 步过该条语句，发现地址 <strong>0240F674</strong> 的前8个字节成功初始化为0：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802205621286.png" srcset="/img/load.gif" lazyload alt="初始化成功"></p><p>继续运行程序，<strong>lea获取常量字符串在堆栈中存储的地址 0240F668 并赋值给EAX</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802210135944.png" srcset="/img/load.gif" lazyload alt="F7单步执行"></p><p><strong>F8</strong> 步过 <strong>strlen</strong> 函数，该函数获取字符串长度，并将结果存在 <strong>EAX</strong> 中，<strong>0000000B 表示长度为11个字符</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802210512925.png" srcset="/img/load.gif" lazyload alt="获取字符串长度"></p><p>接下来将继续执行到 <strong>movsx指令</strong> 处，此时，输入字符串和常量字符串的的地址分别存放在 <strong>EAX</strong> 和 <strong>ECX</strong> 中：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802211533531.png" srcset="/img/load.gif" lazyload alt="执行到movsx"></p><p><strong>movsx：带符号扩展指令，如果为负数，符号位补1；在此处将用户输入的字符串的第一个字符传送到edx中</strong>，第一位为 <strong>‘t’，ascii对应74</strong>，根据扩展规则，EDX为 <strong>00000074</strong> ：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802212020051.png" srcset="/img/load.gif" lazyload alt="movsx扩展"></p><p>继续执行，<strong>EAX&#x3D;EDX-14，将常量字符串的地址赋给EDX，ECX&#x3D;0，MOVSX指令将常量字符串的第一个字符扩展后送到edx中，然后对两个字符进行比较</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802212844833.png" srcset="/img/load.gif" lazyload alt="程序分析"></p><p>继续执行函数，发现程序跳转至上面依次遍历字符：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802214016301.png" srcset="/img/load.gif" lazyload alt="遍历字符"></p><p>重新运行一遍程序，将程序断在这里，分析一下程序是如何跳出循环的，<strong>当所有字符都按照上述规则：输入字符串字符-14h&#x3D;常量字符</strong> 遍历完，就会跳出循环：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802215102029.png" srcset="/img/load.gif" lazyload alt="跳出循环"></p><p>对程序跳出执行后的部分进行分析，程序对两个字符进行比较时，如果两个字符相同，<strong>堆栈处两个地方的值将分别+1</strong>，若不同，则只有一处+1，如果两个字符串规则运算后完全相同，最后这两处的值将相等，弹窗正确！</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802220535834.png" srcset="/img/load.gif" lazyload alt="实际比较结果"></p><h4 id="程序破解-1"><a href="#程序破解-1" class="headerlink" title="程序破解"></a>程序破解</h4><p>理清楚整个程序的思路后，破解就相对简单了，可以采用之前通用思路，将条件跳转改为无条件跳转，这里就不再演示，这次采用另外一种方法，通过注册机来实现破解，根据先前的代码分析，可以得到：<strong>输入字符-14h&#x3D;字符串常量中的字符</strong>，因此，正确的序列号为 <strong>字符串常量中的字符依次+14h</strong>，实现上述过程：</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-dozvf5lli9jctd"></i><span>c</span><div class="collapse show" id="collapse-dozvf5lli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">char</span> st[] = <span class="hljs-string">&quot;10445678951&quot;</span>;<br><span class="hljs-type">char</span>* ptr = st;<br><span class="hljs-keyword">while</span> (*ptr != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>&#123;<br>*ptr = (*ptr) + <span class="hljs-number">20</span>;<br>ptr++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Key: %s&quot;</span>, st);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 得到正确序列号为 EDHHIJKLMIE</span><br></code></pre></td></tr></table></div></figure><p><strong>注：</strong> 其实这里有一点没有说明，真正的序列号其实不是 <strong>EDHHIJKLMIE</strong>，真正的序列号是 <strong>EDHHIJKLMI</strong>，比前面少一位，因为字符串实际判断时候，只判断了 <strong>10</strong> 位，并没有判断第 <strong>11</strong>位，具体原因在这里：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802222840955.png" srcset="/img/load.gif" lazyload alt="判断10次"></p><p><strong>edx一直为字符串长度-1，也就是10，ebp-10最开始为0，也就是</strong></p><table><thead><tr><th>EDX</th><th>EBP-10</th><th>判断第几位</th></tr></thead><tbody><tr><td>10</td><td>0</td><td>1</td></tr><tr><td>10</td><td>1</td><td>2</td></tr><tr><td>10</td><td>2</td><td>3</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>10</td><td>10</td><td>11</td></tr></tbody></table><p>可以看到，当地<strong>EBP-10为10时，该判断第11位，此时还未开始判断，但是上面的条件，当二者相等时，跳出循环，所以没有判断第11位，实际只判断了10位数。</strong></p><!-- #### 扩展 --><p>其实这个程序用 <strong>IDA</strong> 分析更简单，将程序拖入 <strong>IDA</strong> 后，<strong>F5</strong> 一键反汇编，查看程序伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802223648398.png" srcset="/img/load.gif" lazyload alt="IDA查看"></p><p>发现与我们 <strong>OD</strong> 动态分析的没有区别，逻辑完全相同，<strong>Amazing!</strong></p>]]></content>
    
    
    <categories>
      
      <category>使用Ollydbg从零开始Cracking</category>
      
      <category>OD使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ollydbg基础使用</tag>
      
      <tag>硬编码寻踪</tag>
      
      <tag>菜鸡逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ollydbg--硬编码序列号寻踪一</title>
    <link href="/posts/f1a53511/"/>
    <url>/posts/f1a53511/</url>
    
    <content type="html"><![CDATA[<p>介绍Ollydbg的基础用法，通过实例来学习ollydbg的基础操作，了解基本的逆向思路。</p><span id="more"></span><blockquote><p>序列号是最难的工作之一，特别是当我们遇到了强力的加密算法的时候，就更难了，先从简单的情况分析开始，慢慢的延伸到复杂的情况，逐步锻炼寻找序列号的能力。</p></blockquote><h3 id="示例一：Leccion-13-HARDCODED-1"><a href="#示例一：Leccion-13-HARDCODED-1" class="headerlink" title="示例一：Leccion_13_HARDCODED_1"></a>示例一：Leccion_13_HARDCODED_1</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>最简单的情况下，正确的序列号是作为<strong>全局字符串</strong>出现在程序中的，我们先用OD打开该程序，程序停在了函数入口点(401000)处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230731234434167.png" srcset="/img/load.gif" lazyload alt="OD载入"></p><p>搜索全局字符串，如果安装有插件的话，直接使用“<strong>中文搜索引擎–智能搜索</strong>”即可搜索到全局字符串，也可以使用另外一种方式搜索，“<strong>查找–所有参考文本子串</strong>”，其实在使用这种方式搜索时候，并没有找到全部的字符串，猜测可能是字符编码的问题，<strong>建议还是使用插件去搜索，比较全</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230731234735665.png" srcset="/img/load.gif" lazyload alt="中文搜索引擎搜索"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230731235143887.png" srcset="/img/load.gif" lazyload alt="查找字符串"></p><p>搜索的全部字符串结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801002630829.png" srcset="/img/load.gif" lazyload alt="字符串结果"></p><p>其实看到 <strong>“FIACA”</strong> 这个字符串，我们猜测它可能就是我们要找的序列号，但有些程序也会故意放置一些假的序列号在字符串列表中，引诱我们上当，接下来我们去检查字符串的正确性。</p><p>查看当前模块的API函数列表(快捷键<strong>ctrl+N</strong>)，发现有几个比较熟悉的API函数<strong>GetDlgItemTextA</strong> 和 <strong>MessageBoxA</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801002846244.png" srcset="/img/load.gif" lazyload alt="查看API函数列表"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003012079.png" srcset="/img/load.gif" lazyload alt="当前模块的API函数"></p><p>给这两个API函数设置断点，也可以在命令栏输入 <strong>bp GetDlgItemTextA</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003210578.png" srcset="/img/load.gif" lazyload alt="API断点"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003331018.png" srcset="/img/load.gif" lazyload alt="API断点"></p><p>断点设置完成后，当程序运行到断点处就会断下来，按 <strong>F9</strong> 运行程序：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003438364.png" srcset="/img/load.gif" lazyload alt="F9运行程序"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003534063.png" srcset="/img/load.gif" lazyload alt="输入序列号"></p><p>输入序列号后，点击 <strong>Verificar</strong> ，程序断在 <strong>GetDlgItemTextA</strong> 入口处，在堆栈区可以看到，该函数指定的缓冲区地址Buffer为 <strong>403010</strong>，我们在数据窗口中跟随该位置（右键–数据窗口中跟随）：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003741801.png" srcset="/img/load.gif" lazyload alt="程序暂停"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801004135535.png" srcset="/img/load.gif" lazyload alt="跟随堆栈"></p><p>暂时不关心具体函数是怎么执行的，我们只关心结果，<strong>执行到返回(F9)</strong> ，此时用户输入的数据已经被写入该缓冲区：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801004326799.png" srcset="/img/load.gif" lazyload alt="执行到返回，数据存储在缓冲区"></p><p>继续单步执行 <strong>F7</strong> 到用户代码，可以看到有比较和跳转指令，程序获取到用户输入后，将正确的序列号 <strong>FIACA</strong> 存放在EDX处，将用户的输入存放在EBX里，然后两个值进行比较，分别对应下面两个分支：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801004741217.png" srcset="/img/load.gif" lazyload alt="分支语句"></p><p>执行CMP指令时，两个地方存储的数据可以在下方状态窗口看到，显然二者数据不等：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801005532580.png" srcset="/img/load.gif" lazyload alt="数据比较"></p><p>比较过后，<strong>ZF</strong> 标志位置0，无法跳转至正确弹窗：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801011314334.png" srcset="/img/load.gif" lazyload alt="比较过程分析"></p><p><strong>F9</strong>运行程序， 结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801010114032.png" srcset="/img/load.gif" lazyload alt="错误弹窗"></p><h4 id="程序破解"><a href="#程序破解" class="headerlink" title="程序破解"></a>程序破解</h4><p>好了，现在我们已经知道了整个的序列号，也清楚了整个过程，我们使用 <strong>FIACA</strong> 测试一下是否正确，结果如下(其实这个就是正确弹窗，只是没有修改窗口标题)：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801010324846.png" srcset="/img/load.gif" lazyload alt="正确弹窗"></p><p>接下来，尝试对程序进行破解，使错误的序列号也能正确弹窗，继续运行程序到跳转位置，将跳转语句改为无条件跳转 <strong>JMP</strong>，使其跳转至正确弹窗，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801011511665.png" srcset="/img/load.gif" lazyload alt="无条件跳转"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801011546147.png" srcset="/img/load.gif" lazyload alt="正确弹窗"></p><p>每次修改太麻烦，可以选择对修改进行保存，右键“复制到可执行文件–所有修改”，选择全部复制，然后保存文件即可。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801011706716.png" srcset="/img/load.gif" lazyload alt="保存修改"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801011827679.png" srcset="/img/load.gif" lazyload alt="保存文件"></p><p><strong>注：</strong> 其实上面有个细节，真正的序列号并不是 <strong>FIACA</strong>，而是 <strong>FIAC</strong>，因为比较时，<strong>ebx</strong>和 <strong>dword ptr</strong> 都是32位的，实际上只比较了 <strong>4个字节</strong>。</p><h3 id="示例二：Leccon-13-HARDCODED-2"><a href="#示例二：Leccon-13-HARDCODED-2" class="headerlink" title="示例二：Leccon 13 HARDCODED 2"></a>示例二：Leccon 13 HARDCODED 2</h3><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>有了上面的分析经验后，来继续分析第二个程序，使用OD载入该程序，程序停止了函数入口点（401000）处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801211529276.png" srcset="/img/load.gif" lazyload alt="OD载入"></p><p>接下来查找全局字符串，发现可疑字符串 <strong>Bravo</strong> 和 <strong>9898</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801211626876.png" srcset="/img/load.gif" lazyload alt="字符串查找"></p><p>无法确定上述字符串是否为序列号，查看 <strong>当前模块API函数列表</strong> ，发现 <strong>GetDlgItemTextA</strong> 和 <strong>MessageBoxA</strong> ，分别用来获取输入和弹窗：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801211817497.png" srcset="/img/load.gif" lazyload alt="API函数列表"></p><p>在这 <strong>两个函数下断点</strong> ，<strong>F9</strong> 一键运行程序，输入 <strong>test1234</strong>，程序断在 <strong>GetDlgItemTextA</strong> 函数入口处，缓冲区地址为 <strong>40300C</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801212259130.png" srcset="/img/load.gif" lazyload alt="序列号输入"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801212602679.png" srcset="/img/load.gif" lazyload alt="程序到达断点处暂停"></p><p>继续执行程序到返回，缓冲区成功写入用户输入：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801212751493.png" srcset="/img/load.gif" lazyload alt="执行到返回"></p><p>单步执行（<strong>F7</strong>）跳出函数，发现对两个值进行判断后，弹窗正确或错误。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801213026039.png" srcset="/img/load.gif" lazyload alt="字符串比较"></p><p>对函数逻辑进行分析：<strong>第一处mov指令将EBX的值赋为缓冲区的前四个字节，第二处mov指令将40204B处的值(9898)存到EDX中，然后对两个值进行比较</strong>，很明显，EBX和EDX不相等导致<strong>跳转未实现</strong> ， 执行函数查看具体情况：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801213809056.png" srcset="/img/load.gif" lazyload alt="比较结果"></p><p><strong>F9</strong> 继续运行程序，弹窗错误：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801214022122.png" srcset="/img/load.gif" lazyload alt="错误弹窗"></p><h4 id="程序破解-1"><a href="#程序破解-1" class="headerlink" title="程序破解"></a>程序破解</h4><p>知道了跳转的位置，我们可以得到正确的序列号为 <strong>9898</strong> ，也可以尝试对程序进行破解，将跳转语句修改为 <strong>无条件跳转</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801214247938.png" srcset="/img/load.gif" lazyload alt="无条件跳转"></p><p><strong>复制到可执行文件–所有修改–全部复制–保存文件</strong>，打开修改后的文件，输入任意字符串，弹窗正确。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801214629261.png" srcset="/img/load.gif" lazyload alt="弹窗正确"></p>]]></content>
    
    
    <categories>
      
      <category>使用Ollydbg从零开始Cracking</category>
      
      <category>OD使用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ollydbg基础使用</tag>
      
      <tag>硬编码寻踪</tag>
      
      <tag>菜鸡逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win程序设计--窗口与消息</title>
    <link href="/posts/2044ef4b/"/>
    <url>/posts/2044ef4b/</url>
    
    <content type="html"><![CDATA[<p>窗口与消息</p><p><strong>没有人会真正记住这种框架的所有细节，通常，windows程序员都是将已有的程序代码复制到新程序中。</strong></p><span id="more"></span><h3 id="窗口的创建"><a href="#窗口的创建" class="headerlink" title="窗口的创建"></a>窗口的创建</h3><p><strong>用户对窗口的输入以“消息”的形式传递给窗口，而窗口也借助消息来与其他窗口进行通信。</strong></p><blockquote><p>应用程序创建的每一个窗口都有一个与之相关联的窗口过程，windows正是通过调用该窗口过程来向窗口传递消息，窗口过程用于处理传递个窗口的消息。</p></blockquote><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-v5hek6lli9jctd"></i><span>c</span><div class="collapse show" id="collapse-v5hek6lli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// HELLOWIN.C  -- Display &quot;Hello,Windows 98!&quot; in client area</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br>LRESULT CALLBACK <span class="hljs-title function_">WndProc</span><span class="hljs-params">(HWND, UINT, WPARAM, LPARAM)</span>;<br><span class="hljs-type">int</span> WINAPI <span class="hljs-title function_">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="hljs-type">int</span> iCmdShow)</span><br>&#123;<br><span class="hljs-type">static</span> TCHAR szAppName[] = TEXT(<span class="hljs-string">&quot;HelloWin*&quot;</span>);<br>HWND hwnd;<br>MSG msg;<br>WNDCLASS wndclass;<br>wndclass.style = CS_HREDRAW | CS_VREDRAW;<span class="hljs-comment">// 保持 文本位置在窗口中心</span><br>wndclass.lpfnWndProc = WndProc;<span class="hljs-comment">// 窗口过程，函数名相当于指向函数的指针</span><br>wndclass.cbClsExtra = <span class="hljs-number">0</span>;<br>wndclass.cbWndExtra = <span class="hljs-number">0</span>;<br>wndclass.hInstance = hInstance;<span class="hljs-comment">// 应用程序的实例句柄</span><br>wndclass.hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<br>wndclass.hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<br>wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<br>wndclass.lpszMenuName = <span class="hljs-literal">NULL</span>;<br>wndclass.lpszClassName = szAppName;<span class="hljs-comment">// 窗口类的名称</span><br><span class="hljs-keyword">if</span> (!RegisterClass(&amp;wndclass))<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">&quot;This program requires Windows NT!&quot;</span>), szAppName, MB_ICONERROR);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>hwnd = CreateWindow(<br>szAppName,<span class="hljs-comment">// 窗口类名称</span><br>TEXT(<span class="hljs-string">&quot;The Hello Program&quot;</span>),<span class="hljs-comment">// 窗口标题</span><br>WS_OVERLAPPEDWINDOW,<br>CW_USEDEFAULT,<br>CW_USEDEFAULT,<br>CW_USEDEFAULT,<br>CW_USEDEFAULT,<br><span class="hljs-literal">NULL</span>,<br><span class="hljs-literal">NULL</span>,<br>hInstance,<br><span class="hljs-literal">NULL</span><br>);<br>ShowWindow(hwnd, iCmdShow);<br>UpdateWindow(hwnd);<br><span class="hljs-keyword">while</span> (GetMessage(&amp;msg,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<span class="hljs-comment">//注册窗口类</span><br>&#123;<br>TranslateMessage(&amp;msg);<br>DispatchMessage(&amp;msg);<br><br>&#125;<br><span class="hljs-keyword">return</span> msg.wParam;<br><br>&#125;<br><br>LRESULT CALLBACK <span class="hljs-title function_">WndProc</span><span class="hljs-params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br>&#123;<br>HDC hdc;<br>PAINTSTRUCT ps;<br>RECT rect;<br><span class="hljs-keyword">switch</span> (message)<br>&#123;<br><span class="hljs-keyword">case</span> WM_CREATE:<br>PlaySound(TEXT(<span class="hljs-string">&quot;hellowin.wav&quot;</span>), <span class="hljs-literal">NULL</span>, SND_FILENAME | SND_ASYNC);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> WM_PAINT:<br>hdc = BeginPaint(hwnd, &amp;ps);<br>GetClientRect(hwnd, &amp;rect);<br>DrawText(hdc, TEXT(<span class="hljs-string">&quot;Hello,Windows 98!&quot;</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<br>EndPaint(hwnd, &amp;ps);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> WM_DESTROY:<br>PostQuitMessage(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);<br>&#125;<br></code></pre></td></tr></table></div></figure><p>该程序创建了一个普通的应用程序窗口，运行效果如下（带有音频播放）：</p><p><img src="/posts/2044ef4b/result.png" srcset="/img/load.gif" lazyload alt="运行结果"></p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="WinMain函数"><a href="#WinMain函数" class="headerlink" title="WinMain函数"></a>WinMain函数</h5><p>像main函数是C程序的入口一样，Windows程序的入口是<strong>WinMain</strong>，它总是以下面的形式出现：</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-94lsq8lli9jctd"></i><span>C</span><div class="collapse show" id="collapse-94lsq8lli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> WINAPI <span class="hljs-title function_">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="hljs-type">int</span> iCmdShow)</span><br></code></pre></td></tr></table></div></figure><p>第一个参数：<strong>“实例句柄”</strong>，在windows程序中，句柄无非就是一个数值，程序里用它来标识某些东西。在这个例子里，这个句柄就唯一标识了我们的程序。</p><p>第二个参数：上一个实例的句柄，在32位windows中，始终未空(定义为0)。</p><p>第三个参数：用来运行程序的命令行。</p><p>第四个参数：指明程序最初如何显示：或正常显示，或最大化到全屏，或最小化显示在任务栏上。</p><h5 id="WndProc函数"><a href="#WndProc函数" class="headerlink" title="WndProc函数"></a>WndProc函数</h5><p>该函数正是<strong>窗口过程</strong>，在本程序中，并未出现任何调用<strong>WndProc</strong>的代码，但在<strong>WinMain</strong>中，有一个对<strong>WndProc</strong>的引用，这也正是该函数在这段程序非常考前位置声明的原因。</p><h5 id="Windows函数调用"><a href="#Windows函数调用" class="headerlink" title="Windows函数调用"></a>Windows函数调用</h5><p>绝大多数根据名字就能猜到具体功能，这里只解释部分函数的调用</p><table><thead><tr><th>函数名称</th><th>功能</th></tr></thead><tbody><tr><td>GetStockObject</td><td>获取一个图形对象，本例中是用来对窗口的背景进行重绘的画刷</td></tr><tr><td>RegisterClass</td><td>为应用程序的窗口注册一个窗口类</td></tr><tr><td>GetMessage</td><td>从消息队列获取消息</td></tr><tr><td>DispatchMessage</td><td>将消息发送给窗口过程</td></tr><tr><td>GetClientRect</td><td>获取窗口客户区的尺寸</td></tr><tr><td>PostQuitMessage</td><td>将<strong>”退出“</strong>消息插入消息队列</td></tr><tr><td>DefWindowProc</td><td>执行默认的消息处理</td></tr></tbody></table><h5 id="四种数据结构"><a href="#四种数据结构" class="headerlink" title="四种数据结构"></a>四种数据结构</h5><table><thead><tr><th>结构</th><th>含义</th></tr></thead><tbody><tr><td>MSG</td><td>消息结构</td></tr><tr><td>WNDCLASS</td><td>窗口类结构</td></tr><tr><td>PAINTSTRUCT</td><td>绘制结构</td></tr><tr><td>RECT</td><td>矩形结构</td></tr></tbody></table><h5 id="理解句柄"><a href="#理解句柄" class="headerlink" title="理解句柄"></a>理解句柄</h5><p>各种类型的句柄，有以下三种大写标识符：</p><table><thead><tr><th>标识符</th><th>含义</th></tr></thead><tbody><tr><td>HINSTANCE</td><td>实例句柄–程序本身</td></tr><tr><td>HWND</td><td>窗口句柄</td></tr><tr><td>HDC</td><td>设备环境句柄</td></tr></tbody></table><p><strong>句柄本质上是引用某个对象的数值（通常为32位）。</strong>一般情况下，应用程序几乎总是通过调用Windows函数来获取句柄，应用程序通过在其他Windows函数中使用句柄来引用相应对象。</p><h5 id="匈牙利标记法"><a href="#匈牙利标记法" class="headerlink" title="匈牙利标记法"></a>匈牙利标记法</h5><p><strong>即变量名以表明该变量数据类型的小写字母开始。</strong></p><table><thead><tr><th>前缀</th><th>数据类型</th></tr></thead><tbody><tr><td>by</td><td>BYTE</td></tr><tr><td>n</td><td>short</td></tr><tr><td>B或f</td><td>BOOL：f标识flag</td></tr><tr><td>w</td><td>word（无符号短整型）</td></tr><tr><td>l</td><td>long（长整型）</td></tr><tr><td>fn</td><td>函数</td></tr><tr><td>sz</td><td>以0结束的字符串</td></tr><tr><td>h</td><td>句柄</td></tr><tr><td>p</td><td>指针</td></tr></tbody></table><h4 id="窗口类的注册"><a href="#窗口类的注册" class="headerlink" title="窗口类的注册"></a>窗口类的注册</h4><p><strong>窗口总是基于窗口类来创建的，窗口类确定了处理窗口消息的窗口过程。</strong></p><p>在创建窗口应用程序之前，必须调用函数<strong>RegisterClass</strong>来注册窗口类。</p><h4 id="窗口的创建-1"><a href="#窗口的创建-1" class="headerlink" title="窗口的创建"></a>窗口的创建</h4><p>窗口类只是定义了窗口的一般特征，基于同一窗口类可以创建许多不同的窗口。</p><p><strong>CreateWindow</strong>函数的返回值为一个指向所创建窗口的句柄，该句柄保存在变量hwnd中，该变量被定义为HWND类型。许多Windows函数都以hwnd为输入参数，以便Windows获知该函数是对哪个窗口进行引用。</p><h4 id="窗口的显示"><a href="#窗口的显示" class="headerlink" title="窗口的显示"></a>窗口的显示</h4><blockquote><p>当<strong>CreateWindow</strong>调用返回时，窗口已在Windows内部被创建，这句话的基本意思时，Windows已经分配了一块内存来保存<strong>CreateWindow</strong>调用中指定的窗口信息以及一些其他信息。</p></blockquote><p>要将窗口显示在屏幕上，还需要调用另外两个函数：<strong>ShowWindow</strong>和<strong>UpdateWindow</strong></p><h4 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h4><p><strong>Windows为每一个Windows程序都维护了一个“消息队列”，</strong>当输入事件发生后，Windows会自动将这些事件转换为“消息”，并将其放置在应用程序的消息队列中。</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-p1rd5ylli9jctd"></i><span>C</span><div class="collapse show" id="collapse-p1rd5ylli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span> (GetMessage(&amp;msg,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>&#123;<br>TranslateMessage(&amp;msg);<br>DispatchMessage(&amp;msg);<br>&#125;<br></code></pre></td></tr></table></div></figure><p>Windows调用了窗口过程，当<strong>WndProc</strong>处理完消息后，将控制器转回给Windows。</p><h4 id="窗口过程"><a href="#窗口过程" class="headerlink" title="窗口过程"></a>窗口过程</h4><p><strong>窗口过程决定了窗口客户区的显示内容以及窗口如何对用户的输入做出响应。</strong>窗口过程的名称可以任意命名，一个windows程序可以包含多个窗口过程，但是一个窗口过程总是与一个通过调用<strong>RegisterClass</strong>注册的特定窗口类相关联。</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-26rjbwlli9jctd"></i><span>C</span><div class="collapse show" id="collapse-26rjbwlli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">LRESULT CALLBACK <span class="hljs-title function_">WndProc</span><span class="hljs-params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br></code></pre></td></tr></table></div></figure><p>窗口过程的4个参数与MSG结构的前4个字段时一一对应的，应用程序通常并不直接对窗口过程进行调用，窗口过程几乎总是由Windows自身调用。</p><h4 id="消息的处理"><a href="#消息的处理" class="headerlink" title="消息的处理"></a>消息的处理</h4><p>通常，使用switch-case结构来确定窗口过程所接收到的消息的类型以及相应的处理方法，当窗口过程对消息进行处理后，应返回0。</p><p>所有窗口过程不进行处理的消息都必须传给名称为<strong>DefWindowProc</strong>的Windows函数。</p>]]></content>
    
    
    <categories>
      
      <category>Windows程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Window程序设计</tag>
      
      <tag>API编程</tag>
      
      <tag>窗口与消息</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo基本使用</title>
    <link href="/posts/11292/"/>
    <url>/posts/11292/</url>
    
    <content type="html"><![CDATA[<p>Hexo相关的一些基础配置说明。</p><span id="more"></span><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>front-matter是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，例如</p><figure class="highlight yaml"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-m83hc8lli9jctd"></i><span>yaml</span><div class="collapse show" id="collapse-m83hc8lli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">1996</span><span class="hljs-string">/01/01</span> <span class="hljs-number">00</span><span class="hljs-string">:00:00</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></div></figure><p>常用的参数如下：</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>config.default_layout</td></tr><tr><td>title</td><td>标题</td><td>文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启评论</td><td>true</td></tr><tr><td>tags</td><td>标签</td><td>&#x2F;</td></tr><tr><td>categories</td><td>分类（文章分类）</td><td>&#x2F;</td></tr><tr><td>hide</td><td>隐藏文章</td><td>默认false</td></tr><tr><td>index_img</td><td>文章封面图</td><td>&#x2F;</td></tr><tr><td>banner_img</td><td>文章顶部大图</td><td>&#x2F;</td></tr></tbody></table><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote><p>“站点配置” 指的 Hexo 博客目录下的 <em><strong>config.yml</strong>，”主题配置” 指的是 theme&#x2F;fluid&#x2F;</em><strong>config.yml</strong> 或者 <strong>_config.fluid.yml</strong></p></blockquote><p>只要存在于 <strong>_config.fluid.yml</strong> 的配置都是高优先级，修改原 <strong>_config.yml</strong>是无效的，创建该文件主要是为了后续升级方便。</p><h3 id="文字摘要"><a href="#文字摘要" class="headerlink" title="文字摘要"></a>文字摘要</h3><p>摘要默认自动开启，有两种方式来手动指定摘要：</p><figure class="highlight yaml"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-t5eobplli9jctd"></i><span>yaml</span><div class="collapse show" id="collapse-t5eobplli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">正文一部分作为摘要</span><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">more</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">正文</span><br></code></pre></td></tr></table></div></figure><p>另一种是在<strong>Front-matter</strong>中指定，添加 <code>excerpt</code>字段：</p><figure class="highlight yaml"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-4tb07slli9jctd"></i><span>yaml</span><div class="collapse show" id="collapse-4tb07slli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span><br><span class="hljs-attr">date:</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">摘要</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></div></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo 博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 备份、恢复</title>
    <link href="/posts/62245/"/>
    <url>/posts/62245/</url>
    
    <content type="html"><![CDATA[<p>hexo网上搭建教程很多，这里就不再复述了，鉴于每次重装系统后都需要重新部署环境，特意重新写一篇教程来讲述博客备份及恢复。</p><span id="more"></span><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>Hexo博客搭建并部署至github上之后，创建一个新分支用来存放源代码，我这里博客网页静态文件分支为 <strong>main</strong> ，新建一个 <strong>source</strong> 分支来存放代码:</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-i6eon3lli9jctd"></i><span>bash</span><div class="collapse show" id="collapse-i6eon3lli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建新分支之前，需要先初始化git仓库，在本地博客目录下执行:</span><br>git init<br><span class="hljs-comment">## 创建新分支 ， 这里命名为 source</span><br>git checkout -b <span class="hljs-string">&quot;source&quot;</span><br><span class="hljs-comment">## 添加远程仓库 ， 这里仓库名称为博客所在仓库</span><br>git remote add origin 仓库名称<br></code></pre></td></tr></table></div></figure><p>添加远程仓库成功后，配置 <strong>.gitignore</strong> 文件，该文件用来指示哪些文件在push时候忽略，默认已经配置好了，我这里内容为:</p><figure class="highlight yaml"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-bnx4k7lli9jctd"></i><span>yaml</span><div class="collapse show" id="collapse-bnx4k7lli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">## gitignore文件内容</span><br><span class="hljs-string">.DS_Store</span><br><span class="hljs-string">Thumbs.db</span><br><span class="hljs-string">db.json</span><br><span class="hljs-string">*.log</span><br><span class="hljs-string">node_modules/</span><br><span class="hljs-string">public/</span><br><span class="hljs-string">.deploy*/</span><br><span class="hljs-string">_multiconfig.yml</span><br></code></pre></td></tr></table></div></figure><p>接下来使用组合技:</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-19wooblli9jctd"></i><span>bash</span><div class="collapse show" id="collapse-19wooblli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;注释信息&quot;</span><br><span class="hljs-comment">## 要提交的是 source 分支</span><br>git push origin <span class="hljs-built_in">source</span><br></code></pre></td></tr></table></div></figure><p>提交成功后，仓库会新增一个 <strong>source</strong> 分支，该分支内容如下:</p><figure class="highlight yaml"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-rn77fqlli9jctd"></i><span>yaml</span><div class="collapse show" id="collapse-rn77fqlli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">.github</span><br><span class="hljs-string">scaffolds</span><br><span class="hljs-string">source</span><br><span class="hljs-string">themes</span><br><span class="hljs-string">.gitignore</span><br><span class="hljs-string">_config.fluid.yml</span><br><span class="hljs-string">_config.yml</span><br><span class="hljs-string">package-lock.json</span><br><span class="hljs-string">package.json</span><br></code></pre></td></tr></table></div></figure><p>至此博客的备份任务已经完成，当博客源代码有改动时候，便可将改动提交到该分支。</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p><strong>注意</strong>：如果用的是windows备份的，最好恢复也是在windows平台，用其他平台也可以恢复，可能会有部分依赖安装失败问题。</p><p>这里用windows平台举例，假设windows机器刚装完系统，未配置任何环境，先安装 <strong>git</strong>、<strong>nodejs</strong> 环境。</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-xt1sg0lli9jctd"></i><span>bash</span><div class="collapse show" id="collapse-xt1sg0lli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 配置git信息</span><br>git config --global user.name yourname<br>git config --global user.email youremail<br><span class="hljs-comment">## 如果已经有公钥，将公钥上传到github，若无，重新创建</span><br>ssh-keygen -t rsa -C youremail<br><span class="hljs-comment">## 安装完nodejs环境后,安装hexo命令</span><br>npm install hexo-cli -g<br></code></pre></td></tr></table></div></figure><p>克隆远程仓库，注意，拉取 <strong>source</strong> 分支即可</p><p><code>git clone -b source 仓库名称</code></p><p>进入该仓库目录，安装依赖：</p><p><code>npm install</code></p><p>至此博客恢复部署完成，可以在本地尝试一下，看是否正常运行:</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-my462plli9jctd"></i><span>bash</span><div class="collapse show" id="collapse-my462plli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo c // 删除public文件夹<br>hexo g // 在hexo站点根目录下生成public文件夹<br>hexo s // 本地启动服务<br>hexo d // 部署站点，在本地生成.deploy_git文件夹，并将编译后的文件上传至 GitHub<br></code></pre></td></tr></table></div></figure><h2 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips"></a>小Tips</h2><p>每次手动部署推送还是挺麻烦的，使用python脚本一键部署：</p><figure class="highlight python"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-88qxg4lli9jctd"></i><span>python</span><div class="collapse show" id="collapse-88qxg4lli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 一键部署</span><br><span class="hljs-keyword">import</span> os<br>static_cmd=<span class="hljs-string">&quot;hexo c &amp;&amp; hexo g &amp;&amp; hexo d&quot;</span><br>source_cmd=<span class="hljs-string">&quot;git add . &amp;&amp; git commit -m &#x27;source update&#x27; &amp;&amp; git push origin source&quot;</span><br><span class="hljs-keyword">try</span>:<br>    os.system(static_cmd)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;网页push成功！&quot;</span>)<br>    os.system(source_cmd)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;源代码push成功！&quot;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;部署失败，请手动检查情况！&quot;</span>)<br></code></pre></td></tr></table></div></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有时候出现测试git连接失败、或推送失败、部署失败，大概率是因为 <strong>代理</strong> 问题，关闭代理或参考以下方法重新部署：</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-ovwfsnlli9jctd"></i><span>bash</span><div class="collapse show" id="collapse-ovwfsnlli9jctd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 在clash规则里面添加的，用于22端口直连，因为ssh使用的是22端口</span><br>- DST-PORT,22,DIRECT <br><span class="hljs-comment">## 测试git连接</span><br>ssh -T git@github.com<br></code></pre></td></tr></table></div></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo 博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
