<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Ollydbg--硬编码序列号寻踪三</title>
    <link href="/posts/f0bbe23d/"/>
    <url>/posts/f0bbe23d/</url>
    
    <content type="html"><![CDATA[<p>继续增加难度，对程序序列号进行破解。–未完待续</p><span id="more"></span><h3 id="Splish"><a href="#Splish" class="headerlink" title="Splish"></a>Splish</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p><strong>OD</strong> 打开该程序，断在函数入口点 <strong>401000</strong> 处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803211731113.png" srcset="/img/load.gif" lazyload alt="OD载入"></p><p><strong>查找字符串</strong> ，发现成功输入正确序列号时字符串提示，双击来到引用字符串处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803212230713.png" srcset="/img/load.gif" lazyload alt="查找字符串"></p><p>可以看到通过 <strong>GetWindowTextA</strong> 来获取用户输入，用 <strong>MessageBoxA</strong> 来提示序列号正确性，对 <strong>GetWindowTextA</strong> 处下断点：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803212607309.png" srcset="/img/load.gif" lazyload alt="跳转到字符串引用处"></p><p>继续 <strong>查看当前模块API函数</strong> ，找到 <strong>GetWindowTextA</strong> 和 <strong>MessageBoxA</strong> 函数，对这两个函数下断点：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803211923320.png" srcset="/img/load.gif" lazyload alt="当前模块API函数"></p><p><strong>F9</strong> 一键运行程序到断点，用户输入保存至缓冲区 <strong>403215</strong> 处，然后将 <strong>“hardCoded“ 地址赋给eax，输入序列号地址赋给ebx</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803235313814.png" srcset="/img/load.gif" lazyload alt="获取用户输入"></p><p><strong>对两个字符串逐个字符比较，当字符为空时，跳出循环，如果字符不一致，弹窗错误。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230803235828910.png" srcset="/img/load.gif" lazyload alt="比较过程分析"></p><p>由此处可以确定序列号为 <strong>HardCoded</strong> ，将<strong>EIP设置为40138C，跳出循环</strong>，此时继续往下执行，<strong>弹窗正确</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804000400469.png" srcset="/img/load.gif" lazyload alt="此处设置为新EIP"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804000437108.png" srcset="/img/load.gif" lazyload alt="弹窗正确"></p><h4 id="程序破解"><a href="#程序破解" class="headerlink" title="程序破解"></a>程序破解</h4><p>程序的判断逻辑：<strong>对输入的序列号与正确序列号逐字符进行比较，发现字符不同就弹窗错误，只有字符都相同，才会弹窗正确</strong>，知道了逻辑后，程序的破解就很简单了，破解方法有很多，这里只演示一种常规方法，将逐字符比较的判断语句 <strong>nop</strong> 掉即可：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804001023137.png" srcset="/img/load.gif" lazyload alt="程序破解"></p><p>保存修改，运行程序输入任意序列号，均可以弹窗正确！</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804001141116.png" srcset="/img/load.gif" lazyload alt="弹窗正确"></p><h3 id="SamBo"><a href="#SamBo" class="headerlink" title="SamBo"></a>SamBo</h3><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>用 <strong>OD</strong> 载入该程序，提示该程序可能被 <strong>加壳</strong> ，我们先不管它，尝试加载，程序断在入口点 <strong>4D4001</strong> 处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804004429485.png" srcset="/img/load.gif" lazyload alt="提示加壳"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804004456842.png" srcset="/img/load.gif" lazyload alt="OD载入"></p><p><strong>查看程序内存窗口（alt+M）</strong>，发现程序入口点所属区段起始地址为4D4000，大小为2000H，入口点 <strong>4d4001</strong> ，代码段开始于 <strong>401000</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804005102033.png" srcset="/img/load.gif" lazyload alt="内存窗口"></p><p>从当前入口点开始解密其他区段，然后会跳转到真正的入口点处，<strong>F9</strong> 执行程序。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804005359472.png" srcset="/img/load.gif" lazyload alt="程序窗口"></p><p>弹出Crackme窗口，等待输入序列号，<strong>表明该程序已经在内存中解密区段结束了，现在在执行代码段中的代码，我们在.text区段上设置一个内存访问断点，让程序执行代码段中的代码中断下来。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804005557395.png" srcset="/img/load.gif" lazyload alt="内存访问断点"></p><p>设置断点后，程序断在 <strong>45c85f</strong> 处，程序正在解密内存中的各种区段，我们手动分析一下源代码，<strong>鼠标右键–分析–分析代码</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804005730190.png" srcset="/img/load.gif" lazyload alt="分析代码"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804005949971.png" srcset="/img/load.gif" lazyload alt="分析代码"></p><p>可以看到分析后的代码，现在我们位于代码段，查看当前模块使用了哪些API函数，<strong>为什么刚刚程序加载时候不查看，因为当时查看模块使用的API的话是查看的壳所在模块使用的API函数</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010104736.png" srcset="/img/load.gif" lazyload alt="分析后的代码"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010241817.png" srcset="/img/load.gif" lazyload alt="API函数列表"></p><p>很不幸API函数列表中显示的是一些比较陌生的字符串，接下来尝试查看 <strong>全局字符串</strong> ，看看有没有有用信息，<strong>发现提示成功的字符串</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010459387.png" srcset="/img/load.gif" lazyload alt="全局字符串"></p><p>查看字符串引用地方，发现这里存在 <strong>比较指令和跳转指令，附近还有提示错误的代码块，但是并不是通过调用MessageBoxA函数来提示。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010700724.png" srcset="/img/load.gif" lazyload alt="字符串引用"></p><p>在 <strong>test指令</strong> 处设置断点，并清除之前设置的 <strong>内存断点</strong> ，然后运行程序，输入序列号。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010840952.png" srcset="/img/load.gif" lazyload alt="设置断点"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804010936972.png" srcset="/img/load.gif" lazyload alt="删除内存断点"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011026150.png" srcset="/img/load.gif" lazyload alt="输入序列号"></p><p>程序断下来之后，继续单步执行，发现跳转实现，<strong>F9</strong> 继续运行，弹窗提示成功。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011302041.png" srcset="/img/load.gif" lazyload alt="戏耍弹窗"></p><p>点击确定，发现上一步弹窗是假的，只是<strong>戏耍</strong>我们。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011352103.png" srcset="/img/load.gif" lazyload alt="弹窗二"></p><p>再次输入序列号提交，程序依然断在 <strong>test指令</strong> 处，这次修改标志位尝试不跳转：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011610215.png" srcset="/img/load.gif" lazyload alt="修改标志位"></p><p>运行程序，弹窗成功！</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011641045.png" srcset="/img/load.gif" lazyload alt="弹窗成功"></p><p>得到结论：<strong>这个跳转是觉得序列号是否正确的关键跳转</strong> ，接下来分析一下跳转的具体代码：<strong>test指令前还存在一个call指令，我们这次把断点设置在call指令，查看一下堆栈情况</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804011952145.png" srcset="/img/load.gif" lazyload alt="堆栈分析"></p><p><strong>堆栈中存在刚刚输入的序列号，数据窗口跟随定位到字符串，此时可以看到数据窗口中存在字符串 1556555 ，可能是正确序列号，我们对错误序列号设置内存访问断点，当错误序列号与正确序列号进行比较的话，就会断下来。</strong></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f0bbe23d/image-20230804012218874.png" srcset="/img/load.gif" lazyload alt="内存访问断点"></p><p><strong>F9</strong> 运行程序，如果 <strong>call</strong> 指令中有访问该内存，就会中断下来，实际运行发现中断下来了(文档教程中明确说明：不会中断下来， <strong>此处的call指令并没有对序列号进行对比</strong>)，目前没有搞清楚原因在哪里，也可能是太菜了，先暂停！</p>]]></content>
    
    
    <categories>
      
      <category>使用Ollydbg从零开始Cracking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ollydbg基础使用</tag>
      
      <tag>硬编码寻踪</tag>
      
      <tag>菜鸡逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ollydbg--硬编码序列号寻踪二</title>
    <link href="/posts/b2e77430/"/>
    <url>/posts/b2e77430/</url>
    
    <content type="html"><![CDATA[<p>上一章节中已经讲了OD的一些常用基本操作，并尝试对两个简单的程序进行破解，本章节继续熟悉OD的操作，并增加难度，对两个相对难一点的程序序列号进行破解。</p><span id="more"></span><h3 id="示例一：mielecrackme1"><a href="#示例一：mielecrackme1" class="headerlink" title="示例一：mielecrackme1"></a>示例一：mielecrackme1</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>老规矩，打开OD加载程序，程序断在函数入口点(<strong>401000</strong>)处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801232749135.png" srcset="/img/load.gif" lazyload alt="OD加载程序"></p><p>使用 <strong>中文搜索引擎</strong> 查找全局字符串，发现大量字符串，有经验的话，对字符串进行分析，大概能猜测到序列号：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801232850239.png" srcset="/img/load.gif" lazyload alt="查找字符串"></p><p>无法确定具体序列号，查看 <strong>当前模块API函数列表（ctrl+n）</strong>，发现几个比较重要的API函数：<strong>GetWindowTextA</strong> 用于获取用户输入，<strong>lstrcmpA</strong> 用于字符串的比较，<strong>MessageBoxA</strong> 显示弹窗：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801233131850.png" srcset="/img/load.gif" lazyload alt="当前模块API函数列表"></p><p>根据上一章的经验，我们对 <strong>lstrcmpA</strong> 函数下断点，看看函数是如何进行比较的，<strong>F9</strong> 运行程序：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801233533768.png" srcset="/img/load.gif" lazyload alt="输入序列号"></p><p>程序断在 <strong>lstrcmpA</strong> 函数这里，查看堆栈窗口，发现两个字符串，一个为我们的输入，一个大概率为正确的序列号：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801233729491.png" srcset="/img/load.gif" lazyload alt="程序断在lstrcmpA入口"></p><p>对该函数进行分析，可以发现，<strong>两条mov指令其实就是将两个字符串地址存储在寄存器edx和ecx中</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801234320345.png" srcset="/img/load.gif" lazyload alt="lstrcmpA分析一"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801234651857.png" srcset="/img/load.gif" lazyload alt="lstrcmpA分析二"></p><p>具体API函数的细节我们不再分析，接下来执行到返回，继续单步执行 <strong>F7</strong> 跳转到主模块，发现 <strong>or指令和jnz跳转指令 ，判断返回的eax是否为0，如果不为0则跳转至错误弹窗</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801235135739.png" srcset="/img/load.gif" lazyload alt="判断EAX是否为0"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801235527313.png" srcset="/img/load.gif" lazyload alt="跳转实现，弹窗错误"></p><p><strong>F9</strong> 运行程序，弹窗错误：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801235644233.png" srcset="/img/load.gif" lazyload alt="弹窗错误"></p><p>接下来我们尝试一下输入正确的序列号 <strong>cannabis</strong> ，看看程序的执行过程：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801235822439.png" srcset="/img/load.gif" lazyload alt="输入正确序列号"></p><p>可以看到，当输入正确序列号时，<strong>lstrcmpA</strong> 函数执行过后 <strong>EAX的值为0</strong>，此时将跳转失败，弹窗正确：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230801235954012.png" srcset="/img/load.gif" lazyload alt="EAX=0"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802000105776.png" srcset="/img/load.gif" lazyload alt="弹窗正确"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802000141188.png" srcset="/img/load.gif" lazyload alt="运行结果"></p><h4 id="程序破解"><a href="#程序破解" class="headerlink" title="程序破解"></a>程序破解</h4><p>程序的破解也很简单，知道了整个流程，只需将程序的跳转语句 <strong>nop</strong> 掉，不执行跳转即可：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802000401501.png" srcset="/img/load.gif" lazyload alt="nop掉跳转语句"></p><p>将文件保存后运行，输入任意字符串，破解成功：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802000559343.png" srcset="/img/load.gif" lazyload alt="破解成功"></p><p><strong>注：</strong> 此例中新增了个函数 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/winbase/nf-winbase-lstrcmpa">lstrcmpA</a>，该函数对两个字符串进行比较，如果相等则返回0，在此例中，返回结果保存在 <strong>EAX</strong> 中，用 <strong>OR</strong> 判断 <strong>EAX</strong> 是否为0，若为0，则证明两个字符串相等。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802003105878.png" srcset="/img/load.gif" lazyload alt="lstrcmpa函数"></p><h3 id="示例二：crakmeeasy"><a href="#示例二：crakmeeasy" class="headerlink" title="示例二：crakmeeasy"></a>示例二：crakmeeasy</h3><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>使用 <strong>OD</strong> 载入该程序，程序断在函数入口点（<strong>4011F0</strong>）处：<br><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802200907261.png" srcset="/img/load.gif" lazyload alt="OD载入"></p><p><strong>查找全局字符串</strong>，发现一组神秘数字：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802201009416.png" srcset="/img/load.gif" lazyload alt="查找字符串"></p><p>仅凭数字是无法确定序列号的，<strong>查看该模块的API函数列表</strong> ，发现可能有关的API函数 <strong>GetDlgItemTextA</strong> 和 <strong>memset</strong> ，对 <strong>GetDlgItemTextA</strong> 函数下断点：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802201252164.png" srcset="/img/load.gif" lazyload alt="API函数列表"></p><p><strong>F9</strong> 运行程序，输入序列号 <strong>test1234</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802202234413.png" srcset="/img/load.gif" lazyload alt="输入序列号"></p><p>程序断在 <strong>GetDlgItemTextA</strong> 处，继续执行到返回，用户输入存储在 <strong>0FE3CB10</strong> 处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802202458948.png" srcset="/img/load.gif" lazyload alt="执行到返回"></p><p>继续 <strong>F7</strong> 单步执行程序返回到主模块，可以看到，下面两个API函数分别为 <strong>memset</strong> 和 <strong>strlen</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802202617459.png" srcset="/img/load.gif" lazyload alt="单步执行"></p><p>分析程序逻辑，<strong>EAX存储字符串 “10445678951” 的地址，当执行到lea指令时，该字符串的值都已经存储在堆栈处的位置</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802203256502.png" srcset="/img/load.gif" lazyload alt="程序分析"></p><p>接下来调用 <strong>memset</strong> 函数，该函数有三个参数 <strong>(n,c,s)</strong>:</p><blockquote><p>s： 待填充的内存单元的起始地址</p><p>n：需要填充的字节数</p><p>c：待填充的值</p></blockquote><p><strong>F8</strong> 步过该条语句，发现地址 <strong>0240F674</strong> 的前8个字节成功初始化为0：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802205621286.png" srcset="/img/load.gif" lazyload alt="初始化成功"></p><p>继续运行程序，<strong>lea获取常量字符串在堆栈中存储的地址 0240F668 并赋值给EAX</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802210135944.png" srcset="/img/load.gif" lazyload alt="F7单步执行"></p><p><strong>F8</strong> 步过 <strong>strlen</strong> 函数，该函数获取字符串长度，并将结果存在 <strong>EAX</strong> 中，<strong>0000000B 表示长度为11个字符</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802210512925.png" srcset="/img/load.gif" lazyload alt="获取字符串长度"></p><p>接下来将继续执行到 <strong>movsx指令</strong> 处，此时，输入字符串和常量字符串的的地址分别存放在 <strong>EAX</strong> 和 <strong>ECX</strong> 中：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802211533531.png" srcset="/img/load.gif" lazyload alt="执行到movsx"></p><p><strong>movsx：带符号扩展指令，如果为负数，符号位补1；在此处将用户输入的字符串的第一个字符传送到edx中</strong>，第一位为 <strong>‘t’，ascii对应74</strong>，根据扩展规则，EDX为 <strong>00000074</strong> ：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802212020051.png" srcset="/img/load.gif" lazyload alt="movsx扩展"></p><p>继续执行，<strong>EAX&#x3D;EDX-14，将常量字符串的地址赋给EDX，ECX&#x3D;0，MOVSX指令将常量字符串的第一个字符扩展后送到edx中，然后对两个字符进行比较</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802212844833.png" srcset="/img/load.gif" lazyload alt="程序分析"></p><p>继续执行函数，发现程序跳转至上面依次遍历字符：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802214016301.png" srcset="/img/load.gif" lazyload alt="遍历字符"></p><p>重新运行一遍程序，将程序断在这里，分析一下程序是如何跳出循环的，<strong>当所有字符都按照上述规则：输入字符串字符-14h&#x3D;常量字符</strong> 遍历完，就会跳出循环：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802215102029.png" srcset="/img/load.gif" lazyload alt="跳出循环"></p><p>对程序跳出执行后的部分进行分析，程序对两个字符进行比较时，如果两个字符相同，<strong>堆栈处两个地方的值将分别+1</strong>，若不同，则只有一处+1，如果两个字符串规则运算后完全相同，最后这两处的值将相等，弹窗正确！</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802220535834.png" srcset="/img/load.gif" lazyload alt="实际比较结果"></p><h4 id="程序破解-1"><a href="#程序破解-1" class="headerlink" title="程序破解"></a>程序破解</h4><p>理清楚整个程序的思路后，破解就相对简单了，可以采用之前通用思路，将条件跳转改为无条件跳转，这里就不再演示，这次采用另外一种方法，通过注册机来实现破解，根据先前的代码分析，可以得到：<strong>输入字符-14h&#x3D;字符串常量中的字符</strong>，因此，正确的序列号为 <strong>字符串常量中的字符依次+14h</strong>，实现上述过程：</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-voiw1mlkyyxkt9"></i><span>c</span><div class="collapse show" id="collapse-voiw1mlkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-type">char</span> st[] = <span class="hljs-string">&quot;10445678951&quot;</span>;<br><span class="hljs-type">char</span>* ptr = st;<br><span class="hljs-keyword">while</span> (*ptr != <span class="hljs-string">&#x27;\0&#x27;</span>)<br>&#123;<br>*ptr = (*ptr) + <span class="hljs-number">20</span>;<br>ptr++;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Key: %s&quot;</span>, st);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 得到正确序列号为 EDHHIJKLMIE</span><br></code></pre></td></tr></table></div></figure><p><strong>注：</strong> 其实这里有一点没有说明，真正的序列号其实不是 <strong>EDHHIJKLMIE</strong>，真正的序列号是 <strong>EDHHIJKLMI</strong>，比前面少一位，因为字符串实际判断时候，只判断了 <strong>10</strong> 位，并没有判断第 <strong>11</strong>位，具体原因在这里：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802222840955.png" srcset="/img/load.gif" lazyload alt="判断10次"></p><p><strong>edx一直为字符串长度-1，也就是10，ebp-10最开始为0，也就是</strong></p><table><thead><tr><th>EDX</th><th>EBP-10</th><th>判断第几位</th></tr></thead><tbody><tr><td>10</td><td>0</td><td>1</td></tr><tr><td>10</td><td>1</td><td>2</td></tr><tr><td>10</td><td>2</td><td>3</td></tr><tr><td>…</td><td>…</td><td>…</td></tr><tr><td>10</td><td>10</td><td>11</td></tr></tbody></table><p>可以看到，当地<strong>EBP-10为10时，该判断第11位，此时还未开始判断，但是上面的条件，当二者相等时，跳出循环，所以没有判断第11位，实际只判断了10位数。</strong></p><!-- #### 扩展 --><p>其实这个程序用 <strong>IDA</strong> 分析更简单，将程序拖入 <strong>IDA</strong> 后，<strong>F5</strong> 一键反汇编，查看程序伪代码：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/b2e77430/image-20230802223648398.png" srcset="/img/load.gif" lazyload alt="IDA查看"></p><p>发现与我们 <strong>OD</strong> 动态分析的没有区别，逻辑完全相同，<strong>Amazing!</strong></p>]]></content>
    
    
    <categories>
      
      <category>使用Ollydbg从零开始Cracking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ollydbg基础使用</tag>
      
      <tag>硬编码寻踪</tag>
      
      <tag>菜鸡逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ollydbg--硬编码序列号寻踪一</title>
    <link href="/posts/f1a53511/"/>
    <url>/posts/f1a53511/</url>
    
    <content type="html"><![CDATA[<p>介绍Ollydbg的基础用法，通过实例来学习ollydbg的基础操作，了解基本的逆向思路。</p><span id="more"></span><blockquote><p>序列号是最难的工作之一，特别是当我们遇到了强力的加密算法的时候，就更难了，先从简单的情况分析开始，慢慢的延伸到复杂的情况，逐步锻炼寻找序列号的能力。</p></blockquote><h3 id="示例一：Leccion-13-HARDCODED-1"><a href="#示例一：Leccion-13-HARDCODED-1" class="headerlink" title="示例一：Leccion_13_HARDCODED_1"></a>示例一：Leccion_13_HARDCODED_1</h3><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>最简单的情况下，正确的序列号是作为<strong>全局字符串</strong>出现在程序中的，我们先用OD打开该程序，程序停在了函数入口点(401000)处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230731234434167.png" srcset="/img/load.gif" lazyload alt="OD载入"></p><p>搜索全局字符串，如果安装有插件的话，直接使用“<strong>中文搜索引擎–智能搜索</strong>”即可搜索到全局字符串，也可以使用另外一种方式搜索，“<strong>查找–所有参考文本子串</strong>”，其实在使用这种方式搜索时候，并没有找到全部的字符串，猜测可能是字符编码的问题，<strong>建议还是使用插件去搜索，比较全</strong>。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230731234735665.png" srcset="/img/load.gif" lazyload alt="中文搜索引擎搜索"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230731235143887.png" srcset="/img/load.gif" lazyload alt="查找字符串"></p><p>搜索的全部字符串结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801002630829.png" srcset="/img/load.gif" lazyload alt="字符串结果"></p><p>其实看到 <strong>“FIACA”</strong> 这个字符串，我们猜测它可能就是我们要找的序列号，但有些程序也会故意放置一些假的序列号在字符串列表中，引诱我们上当，接下来我们去检查字符串的正确性。</p><p>查看当前模块的API函数列表(快捷键<strong>ctrl+N</strong>)，发现有几个比较熟悉的API函数<strong>GetDlgItemTextA</strong> 和 <strong>MessageBoxA</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801002846244.png" srcset="/img/load.gif" lazyload alt="查看API函数列表"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003012079.png" srcset="/img/load.gif" lazyload alt="当前模块的API函数"></p><p>给这两个API函数设置断点，也可以在命令栏输入 <strong>bp GetDlgItemTextA</strong>:</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003210578.png" srcset="/img/load.gif" lazyload alt="API断点"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003331018.png" srcset="/img/load.gif" lazyload alt="API断点"></p><p>断点设置完成后，当程序运行到断点处就会断下来，按 <strong>F9</strong> 运行程序：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003438364.png" srcset="/img/load.gif" lazyload alt="F9运行程序"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003534063.png" srcset="/img/load.gif" lazyload alt="输入序列号"></p><p>输入序列号后，点击 <strong>Verificar</strong> ，程序断在 <strong>GetDlgItemTextA</strong> 入口处，在堆栈区可以看到，该函数指定的缓冲区地址Buffer为 <strong>403010</strong>，我们在数据窗口中跟随该位置（右键–数据窗口中跟随）：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801003741801.png" srcset="/img/load.gif" lazyload alt="程序暂停"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801004135535.png" srcset="/img/load.gif" lazyload alt="跟随堆栈"></p><p>暂时不关心具体函数是怎么执行的，我们只关心结果，<strong>执行到返回(F9)</strong> ，此时用户输入的数据已经被写入该缓冲区：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801004326799.png" srcset="/img/load.gif" lazyload alt="执行到返回，数据存储在缓冲区"></p><p>继续单步执行 <strong>F7</strong> 到用户代码，可以看到有比较和跳转指令，程序获取到用户输入后，将正确的序列号 <strong>FIACA</strong> 存放在EDX处，将用户的输入存放在EBX里，然后两个值进行比较，分别对应下面两个分支：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801004741217.png" srcset="/img/load.gif" lazyload alt="分支语句"></p><p>执行CMP指令时，两个地方存储的数据可以在下方状态窗口看到，显然二者数据不等：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801005532580.png" srcset="/img/load.gif" lazyload alt="数据比较"></p><p>比较过后，<strong>ZF</strong> 标志位置0，无法跳转至正确弹窗：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801011314334.png" srcset="/img/load.gif" lazyload alt="比较过程分析"></p><p><strong>F9</strong>运行程序， 结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801010114032.png" srcset="/img/load.gif" lazyload alt="错误弹窗"></p><h4 id="程序破解"><a href="#程序破解" class="headerlink" title="程序破解"></a>程序破解</h4><p>好了，现在我们已经知道了整个的序列号，也清楚了整个过程，我们使用 <strong>FIACA</strong> 测试一下是否正确，结果如下(其实这个就是正确弹窗，只是没有修改窗口标题)：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801010324846.png" srcset="/img/load.gif" lazyload alt="正确弹窗"></p><p>接下来，尝试对程序进行破解，使错误的序列号也能正确弹窗，继续运行程序到跳转位置，将跳转语句改为无条件跳转 <strong>JMP</strong>，使其跳转至正确弹窗，结果如下：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801011511665.png" srcset="/img/load.gif" lazyload alt="无条件跳转"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801011546147.png" srcset="/img/load.gif" lazyload alt="正确弹窗"></p><p>每次修改太麻烦，可以选择对修改进行保存，右键“复制到可执行文件–所有修改”，选择全部复制，然后保存文件即可。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801011706716.png" srcset="/img/load.gif" lazyload alt="保存修改"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801011827679.png" srcset="/img/load.gif" lazyload alt="保存文件"></p><p><strong>注：</strong> 其实上面有个细节，真正的序列号并不是 <strong>FIACA</strong>，而是 <strong>FIAC</strong>，因为比较时，<strong>ebx</strong>和 <strong>dword ptr</strong> 都是32位的，实际上只比较了 <strong>4个字节</strong>。</p><h3 id="示例二：Leccon-13-HARDCODED-2"><a href="#示例二：Leccon-13-HARDCODED-2" class="headerlink" title="示例二：Leccon 13 HARDCODED 2"></a>示例二：Leccon 13 HARDCODED 2</h3><h4 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h4><p>有了上面的分析经验后，来继续分析第二个程序，使用OD载入该程序，程序停止了函数入口点（401000）处：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801211529276.png" srcset="/img/load.gif" lazyload alt="OD载入"></p><p>接下来查找全局字符串，发现可疑字符串 <strong>Bravo</strong> 和 <strong>9898</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801211626876.png" srcset="/img/load.gif" lazyload alt="字符串查找"></p><p>无法确定上述字符串是否为序列号，查看 <strong>当前模块API函数列表</strong> ，发现 <strong>GetDlgItemTextA</strong> 和 <strong>MessageBoxA</strong> ，分别用来获取输入和弹窗：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801211817497.png" srcset="/img/load.gif" lazyload alt="API函数列表"></p><p>在这 <strong>两个函数下断点</strong> ，<strong>F9</strong> 一键运行程序，输入 <strong>test1234</strong>，程序断在 <strong>GetDlgItemTextA</strong> 函数入口处，缓冲区地址为 <strong>40300C</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801212259130.png" srcset="/img/load.gif" lazyload alt="序列号输入"></p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801212602679.png" srcset="/img/load.gif" lazyload alt="程序到达断点处暂停"></p><p>继续执行程序到返回，缓冲区成功写入用户输入：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801212751493.png" srcset="/img/load.gif" lazyload alt="执行到返回"></p><p>单步执行（<strong>F7</strong>）跳出函数，发现对两个值进行判断后，弹窗正确或错误。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801213026039.png" srcset="/img/load.gif" lazyload alt="字符串比较"></p><p>对函数逻辑进行分析：<strong>第一处mov指令将EBX的值赋为缓冲区的前四个字节，第二处mov指令将40204B处的值(9898)存到EDX中，然后对两个值进行比较</strong>，很明显，EBX和EDX不相等导致<strong>跳转未实现</strong> ， 执行函数查看具体情况：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801213809056.png" srcset="/img/load.gif" lazyload alt="比较结果"></p><p><strong>F9</strong> 继续运行程序，弹窗错误：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801214022122.png" srcset="/img/load.gif" lazyload alt="错误弹窗"></p><h4 id="程序破解-1"><a href="#程序破解-1" class="headerlink" title="程序破解"></a>程序破解</h4><p>知道了跳转的位置，我们可以得到正确的序列号为 <strong>9898</strong> ，也可以尝试对程序进行破解，将跳转语句修改为 <strong>无条件跳转</strong>：</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801214247938.png" srcset="/img/load.gif" lazyload alt="无条件跳转"></p><p><strong>复制到可执行文件–所有修改–全部复制–保存文件</strong>，打开修改后的文件，输入任意字符串，弹窗正确。</p><p><img src="https://cdn.jsdelivr.net/gh/Zanelc/Zanelc.github.io@main/posts/f1a53511/image-20230801214629261.png" srcset="/img/load.gif" lazyload alt="弹窗正确"></p>]]></content>
    
    
    <categories>
      
      <category>使用Ollydbg从零开始Cracking</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ollydbg基础使用</tag>
      
      <tag>硬编码寻踪</tag>
      
      <tag>菜鸡逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Win程序设计--窗口与消息</title>
    <link href="/posts/2044ef4b/"/>
    <url>/posts/2044ef4b/</url>
    
    <content type="html"><![CDATA[<p>窗口与消息</p><p><strong>没有人会真正记住这种框架的所有细节，通常，windows程序员都是将已有的程序代码复制到新程序中。</strong></p><span id="more"></span><h3 id="窗口的创建"><a href="#窗口的创建" class="headerlink" title="窗口的创建"></a>窗口的创建</h3><p><strong>用户对窗口的输入以“消息”的形式传递给窗口，而窗口也借助消息来与其他窗口进行通信。</strong></p><blockquote><p>应用程序创建的每一个窗口都有一个与之相关联的窗口过程，windows正是通过调用该窗口过程来向窗口传递消息，窗口过程用于处理传递个窗口的消息。</p></blockquote><h4 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h4><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-8lzfyalkyyxkt9"></i><span>c</span><div class="collapse show" id="collapse-8lzfyalkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// HELLOWIN.C  -- Display &quot;Hello,Windows 98!&quot; in client area</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;windows.h&gt;</span></span><br>LRESULT CALLBACK <span class="hljs-title function_">WndProc</span><span class="hljs-params">(HWND, UINT, WPARAM, LPARAM)</span>;<br><span class="hljs-type">int</span> WINAPI <span class="hljs-title function_">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="hljs-type">int</span> iCmdShow)</span><br>&#123;<br><span class="hljs-type">static</span> TCHAR szAppName[] = TEXT(<span class="hljs-string">&quot;HelloWin*&quot;</span>);<br>HWND hwnd;<br>MSG msg;<br>WNDCLASS wndclass;<br>wndclass.style = CS_HREDRAW | CS_VREDRAW;<span class="hljs-comment">// 保持 文本位置在窗口中心</span><br>wndclass.lpfnWndProc = WndProc;<span class="hljs-comment">// 窗口过程，函数名相当于指向函数的指针</span><br>wndclass.cbClsExtra = <span class="hljs-number">0</span>;<br>wndclass.cbWndExtra = <span class="hljs-number">0</span>;<br>wndclass.hInstance = hInstance;<span class="hljs-comment">// 应用程序的实例句柄</span><br>wndclass.hIcon = LoadIcon(<span class="hljs-literal">NULL</span>, IDI_APPLICATION);<br>wndclass.hCursor = LoadCursor(<span class="hljs-literal">NULL</span>, IDC_ARROW);<br>wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);<br>wndclass.lpszMenuName = <span class="hljs-literal">NULL</span>;<br>wndclass.lpszClassName = szAppName;<span class="hljs-comment">// 窗口类的名称</span><br><span class="hljs-keyword">if</span> (!RegisterClass(&amp;wndclass))<br>&#123;<br>MessageBox(<span class="hljs-literal">NULL</span>, TEXT(<span class="hljs-string">&quot;This program requires Windows NT!&quot;</span>), szAppName, MB_ICONERROR);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>hwnd = CreateWindow(<br>szAppName,<span class="hljs-comment">// 窗口类名称</span><br>TEXT(<span class="hljs-string">&quot;The Hello Program&quot;</span>),<span class="hljs-comment">// 窗口标题</span><br>WS_OVERLAPPEDWINDOW,<br>CW_USEDEFAULT,<br>CW_USEDEFAULT,<br>CW_USEDEFAULT,<br>CW_USEDEFAULT,<br><span class="hljs-literal">NULL</span>,<br><span class="hljs-literal">NULL</span>,<br>hInstance,<br><span class="hljs-literal">NULL</span><br>);<br>ShowWindow(hwnd, iCmdShow);<br>UpdateWindow(hwnd);<br><span class="hljs-keyword">while</span> (GetMessage(&amp;msg,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<span class="hljs-comment">//注册窗口类</span><br>&#123;<br>TranslateMessage(&amp;msg);<br>DispatchMessage(&amp;msg);<br><br>&#125;<br><span class="hljs-keyword">return</span> msg.wParam;<br><br>&#125;<br><br>LRESULT CALLBACK <span class="hljs-title function_">WndProc</span><span class="hljs-params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br>&#123;<br>HDC hdc;<br>PAINTSTRUCT ps;<br>RECT rect;<br><span class="hljs-keyword">switch</span> (message)<br>&#123;<br><span class="hljs-keyword">case</span> WM_CREATE:<br>PlaySound(TEXT(<span class="hljs-string">&quot;hellowin.wav&quot;</span>), <span class="hljs-literal">NULL</span>, SND_FILENAME | SND_ASYNC);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> WM_PAINT:<br>hdc = BeginPaint(hwnd, &amp;ps);<br>GetClientRect(hwnd, &amp;rect);<br>DrawText(hdc, TEXT(<span class="hljs-string">&quot;Hello,Windows 98!&quot;</span>), <span class="hljs-number">-1</span>, &amp;rect, DT_SINGLELINE | DT_CENTER | DT_VCENTER);<br>EndPaint(hwnd, &amp;ps);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> WM_DESTROY:<br>PostQuitMessage(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">return</span> DefWindowProc(hwnd, message, wParam, lParam);<br>&#125;<br></code></pre></td></tr></table></div></figure><p>该程序创建了一个普通的应用程序窗口，运行效果如下（带有音频播放）：</p><p><img src="/posts/2044ef4b/result.png" srcset="/img/load.gif" lazyload alt="运行结果"></p><h4 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h4><h5 id="WinMain函数"><a href="#WinMain函数" class="headerlink" title="WinMain函数"></a>WinMain函数</h5><p>像main函数是C程序的入口一样，Windows程序的入口是<strong>WinMain</strong>，它总是以下面的形式出现：</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-s3uvhdlkyyxkt9"></i><span>C</span><div class="collapse show" id="collapse-s3uvhdlkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">int</span> WINAPI <span class="hljs-title function_">WinMain</span><span class="hljs-params">(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, <span class="hljs-type">int</span> iCmdShow)</span><br></code></pre></td></tr></table></div></figure><p>第一个参数：<strong>“实例句柄”</strong>，在windows程序中，句柄无非就是一个数值，程序里用它来标识某些东西。在这个例子里，这个句柄就唯一标识了我们的程序。</p><p>第二个参数：上一个实例的句柄，在32位windows中，始终未空(定义为0)。</p><p>第三个参数：用来运行程序的命令行。</p><p>第四个参数：指明程序最初如何显示：或正常显示，或最大化到全屏，或最小化显示在任务栏上。</p><h5 id="WndProc函数"><a href="#WndProc函数" class="headerlink" title="WndProc函数"></a>WndProc函数</h5><p>该函数正是<strong>窗口过程</strong>，在本程序中，并未出现任何调用<strong>WndProc</strong>的代码，但在<strong>WinMain</strong>中，有一个对<strong>WndProc</strong>的引用，这也正是该函数在这段程序非常考前位置声明的原因。</p><h5 id="Windows函数调用"><a href="#Windows函数调用" class="headerlink" title="Windows函数调用"></a>Windows函数调用</h5><p>绝大多数根据名字就能猜到具体功能，这里只解释部分函数的调用</p><table><thead><tr><th>函数名称</th><th>功能</th></tr></thead><tbody><tr><td>GetStockObject</td><td>获取一个图形对象，本例中是用来对窗口的背景进行重绘的画刷</td></tr><tr><td>RegisterClass</td><td>为应用程序的窗口注册一个窗口类</td></tr><tr><td>GetMessage</td><td>从消息队列获取消息</td></tr><tr><td>DispatchMessage</td><td>将消息发送给窗口过程</td></tr><tr><td>GetClientRect</td><td>获取窗口客户区的尺寸</td></tr><tr><td>PostQuitMessage</td><td>将<strong>”退出“</strong>消息插入消息队列</td></tr><tr><td>DefWindowProc</td><td>执行默认的消息处理</td></tr></tbody></table><h5 id="四种数据结构"><a href="#四种数据结构" class="headerlink" title="四种数据结构"></a>四种数据结构</h5><table><thead><tr><th>结构</th><th>含义</th></tr></thead><tbody><tr><td>MSG</td><td>消息结构</td></tr><tr><td>WNDCLASS</td><td>窗口类结构</td></tr><tr><td>PAINTSTRUCT</td><td>绘制结构</td></tr><tr><td>RECT</td><td>矩形结构</td></tr></tbody></table><h5 id="理解句柄"><a href="#理解句柄" class="headerlink" title="理解句柄"></a>理解句柄</h5><p>各种类型的句柄，有以下三种大写标识符：</p><table><thead><tr><th>标识符</th><th>含义</th></tr></thead><tbody><tr><td>HINSTANCE</td><td>实例句柄–程序本身</td></tr><tr><td>HWND</td><td>窗口句柄</td></tr><tr><td>HDC</td><td>设备环境句柄</td></tr></tbody></table><p><strong>句柄本质上是引用某个对象的数值（通常为32位）。</strong>一般情况下，应用程序几乎总是通过调用Windows函数来获取句柄，应用程序通过在其他Windows函数中使用句柄来引用相应对象。</p><h5 id="匈牙利标记法"><a href="#匈牙利标记法" class="headerlink" title="匈牙利标记法"></a>匈牙利标记法</h5><p><strong>即变量名以表明该变量数据类型的小写字母开始。</strong></p><table><thead><tr><th>前缀</th><th>数据类型</th></tr></thead><tbody><tr><td>by</td><td>BYTE</td></tr><tr><td>n</td><td>short</td></tr><tr><td>B或f</td><td>BOOL：f标识flag</td></tr><tr><td>w</td><td>word（无符号短整型）</td></tr><tr><td>l</td><td>long（长整型）</td></tr><tr><td>fn</td><td>函数</td></tr><tr><td>sz</td><td>以0结束的字符串</td></tr><tr><td>h</td><td>句柄</td></tr><tr><td>p</td><td>指针</td></tr></tbody></table><h4 id="窗口类的注册"><a href="#窗口类的注册" class="headerlink" title="窗口类的注册"></a>窗口类的注册</h4><p><strong>窗口总是基于窗口类来创建的，窗口类确定了处理窗口消息的窗口过程。</strong></p><p>在创建窗口应用程序之前，必须调用函数<strong>RegisterClass</strong>来注册窗口类。</p><h4 id="窗口的创建-1"><a href="#窗口的创建-1" class="headerlink" title="窗口的创建"></a>窗口的创建</h4><p>窗口类只是定义了窗口的一般特征，基于同一窗口类可以创建许多不同的窗口。</p><p><strong>CreateWindow</strong>函数的返回值为一个指向所创建窗口的句柄，该句柄保存在变量hwnd中，该变量被定义为HWND类型。许多Windows函数都以hwnd为输入参数，以便Windows获知该函数是对哪个窗口进行引用。</p><h4 id="窗口的显示"><a href="#窗口的显示" class="headerlink" title="窗口的显示"></a>窗口的显示</h4><blockquote><p>当<strong>CreateWindow</strong>调用返回时，窗口已在Windows内部被创建，这句话的基本意思时，Windows已经分配了一块内存来保存<strong>CreateWindow</strong>调用中指定的窗口信息以及一些其他信息。</p></blockquote><p>要将窗口显示在屏幕上，还需要调用另外两个函数：<strong>ShowWindow</strong>和<strong>UpdateWindow</strong></p><h4 id="消息循环"><a href="#消息循环" class="headerlink" title="消息循环"></a>消息循环</h4><p><strong>Windows为每一个Windows程序都维护了一个“消息队列”，</strong>当输入事件发生后，Windows会自动将这些事件转换为“消息”，并将其放置在应用程序的消息队列中。</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-9e44kqlkyyxkt9"></i><span>C</span><div class="collapse show" id="collapse-9e44kqlkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">while</span> (GetMessage(&amp;msg,<span class="hljs-literal">NULL</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))<br>&#123;<br>TranslateMessage(&amp;msg);<br>DispatchMessage(&amp;msg);<br>&#125;<br></code></pre></td></tr></table></div></figure><p>Windows调用了窗口过程，当<strong>WndProc</strong>处理完消息后，将控制器转回给Windows。</p><h4 id="窗口过程"><a href="#窗口过程" class="headerlink" title="窗口过程"></a>窗口过程</h4><p><strong>窗口过程决定了窗口客户区的显示内容以及窗口如何对用户的输入做出响应。</strong>窗口过程的名称可以任意命名，一个windows程序可以包含多个窗口过程，但是一个窗口过程总是与一个通过调用<strong>RegisterClass</strong>注册的特定窗口类相关联。</p><figure class="highlight c"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-iq2kwrlkyyxkt9"></i><span>C</span><div class="collapse show" id="collapse-iq2kwrlkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C">LRESULT CALLBACK <span class="hljs-title function_">WndProc</span><span class="hljs-params">(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)</span><br></code></pre></td></tr></table></div></figure><p>窗口过程的4个参数与MSG结构的前4个字段时一一对应的，应用程序通常并不直接对窗口过程进行调用，窗口过程几乎总是由Windows自身调用。</p><h4 id="消息的处理"><a href="#消息的处理" class="headerlink" title="消息的处理"></a>消息的处理</h4><p>通常，使用switch-case结构来确定窗口过程所接收到的消息的类型以及相应的处理方法，当窗口过程对消息进行处理后，应返回0。</p><p>所有窗口过程不进行处理的消息都必须传给名称为<strong>DefWindowProc</strong>的Windows函数。</p>]]></content>
    
    
    <categories>
      
      <category>Windows程序设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Window程序设计</tag>
      
      <tag>API编程</tag>
      
      <tag>窗口与消息</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo基本使用</title>
    <link href="/posts/11292/"/>
    <url>/posts/11292/</url>
    
    <content type="html"><![CDATA[<p>Hexo相关的一些基础配置说明。</p><span id="more"></span><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><p>front-matter是文件最上方以 <code>---</code> 分隔的区域，用于指定个别文件的变量，例如</p><figure class="highlight yaml"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-ucvq03lkyyxkt9"></i><span>yaml</span><div class="collapse show" id="collapse-ucvq03lkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">Hello</span> <span class="hljs-string">World</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">1996</span><span class="hljs-string">/01/01</span> <span class="hljs-number">00</span><span class="hljs-string">:00:00</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></div></figure><p>常用的参数如下：</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td>layout</td><td>布局</td><td>config.default_layout</td></tr><tr><td>title</td><td>标题</td><td>文件名</td></tr><tr><td>date</td><td>建立日期</td><td>文件建立日期</td></tr><tr><td>updated</td><td>更新日期</td><td>文件更新日期</td></tr><tr><td>comments</td><td>开启评论</td><td>true</td></tr><tr><td>tags</td><td>标签</td><td>&#x2F;</td></tr><tr><td>categories</td><td>分类（文章分类）</td><td>&#x2F;</td></tr><tr><td>hide</td><td>隐藏文章</td><td>默认false</td></tr><tr><td>index_img</td><td>文章封面图</td><td>&#x2F;</td></tr><tr><td>banner_img</td><td>文章顶部大图</td><td>&#x2F;</td></tr></tbody></table><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><blockquote><p>“站点配置” 指的 Hexo 博客目录下的 <em><strong>config.yml</strong>，”主题配置” 指的是 theme&#x2F;fluid&#x2F;</em><strong>config.yml</strong> 或者 <strong>_config.fluid.yml</strong></p></blockquote><p>只要存在于 <strong>_config.fluid.yml</strong> 的配置都是高优先级，修改原 <strong>_config.yml</strong>是无效的，创建该文件主要是为了后续升级方便。</p><h3 id="文字摘要"><a href="#文字摘要" class="headerlink" title="文字摘要"></a>文字摘要</h3><p>摘要默认自动开启，有两种方式来手动指定摘要：</p><figure class="highlight yaml"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-ix5xallkyyxkt9"></i><span>yaml</span><div class="collapse show" id="collapse-ix5xallkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">正文一部分作为摘要</span><br><span class="hljs-string">&lt;!--</span> <span class="hljs-string">more</span> <span class="hljs-string">--&gt;</span><br><span class="hljs-string">正文</span><br></code></pre></td></tr></table></div></figure><p>另一种是在<strong>Front-matter</strong>中指定，添加 <code>excerpt</code>字段：</p><figure class="highlight yaml"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-xeu8z1lkyyxkt9"></i><span>yaml</span><div class="collapse show" id="collapse-xeu8z1lkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span><br><span class="hljs-attr">date:</span><br><span class="hljs-attr">excerpt:</span> <span class="hljs-string">摘要</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></div></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo 博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo 备份、恢复</title>
    <link href="/posts/62245/"/>
    <url>/posts/62245/</url>
    
    <content type="html"><![CDATA[<p>hexo网上搭建教程很多，这里就不再复述了，鉴于每次重装系统后都需要重新部署环境，特意重新写一篇教程来讲述博客备份及恢复。</p><span id="more"></span><h2 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h2><p>Hexo博客搭建并部署至github上之后，创建一个新分支用来存放源代码，我这里博客网页静态文件分支为 <strong>main</strong> ，新建一个 <strong>source</strong> 分支来存放代码:</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-5v9egnlkyyxkt9"></i><span>bash</span><div class="collapse show" id="collapse-5v9egnlkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 创建新分支之前，需要先初始化git仓库，在本地博客目录下执行:</span><br>git init<br><span class="hljs-comment">## 创建新分支 ， 这里命名为 source</span><br>git checkout -b <span class="hljs-string">&quot;source&quot;</span><br><span class="hljs-comment">## 添加远程仓库 ， 这里仓库名称为博客所在仓库</span><br>git remote add origin 仓库名称<br></code></pre></td></tr></table></div></figure><p>添加远程仓库成功后，配置 <strong>.gitignore</strong> 文件，该文件用来指示哪些文件在push时候忽略，默认已经配置好了，我这里内容为:</p><figure class="highlight yaml"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-qcl1x1lkyyxkt9"></i><span>yaml</span><div class="collapse show" id="collapse-qcl1x1lkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">## gitignore文件内容</span><br><span class="hljs-string">.DS_Store</span><br><span class="hljs-string">Thumbs.db</span><br><span class="hljs-string">db.json</span><br><span class="hljs-string">*.log</span><br><span class="hljs-string">node_modules/</span><br><span class="hljs-string">public/</span><br><span class="hljs-string">.deploy*/</span><br><span class="hljs-string">_multiconfig.yml</span><br></code></pre></td></tr></table></div></figure><p>接下来使用组合技:</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-ill060lkyyxkt9"></i><span>bash</span><div class="collapse show" id="collapse-ill060lkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">git add .<br>git commit -m <span class="hljs-string">&quot;注释信息&quot;</span><br><span class="hljs-comment">## 要提交的是 source 分支</span><br>git push origin <span class="hljs-built_in">source</span><br></code></pre></td></tr></table></div></figure><p>提交成功后，仓库会新增一个 <strong>source</strong> 分支，该分支内容如下:</p><figure class="highlight yaml"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-pvrlp1lkyyxkt9"></i><span>yaml</span><div class="collapse show" id="collapse-pvrlp1lkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">.github</span><br><span class="hljs-string">scaffolds</span><br><span class="hljs-string">source</span><br><span class="hljs-string">themes</span><br><span class="hljs-string">.gitignore</span><br><span class="hljs-string">_config.fluid.yml</span><br><span class="hljs-string">_config.yml</span><br><span class="hljs-string">package-lock.json</span><br><span class="hljs-string">package.json</span><br></code></pre></td></tr></table></div></figure><p>至此博客的备份任务已经完成，当博客源代码有改动时候，便可将改动提交到该分支。</p><h2 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h2><p><strong>注意</strong>：如果用的是windows备份的，最好恢复也是在windows平台，用其他平台也可以恢复，可能会有部分依赖安装失败问题。</p><p>这里用windows平台举例，假设windows机器刚装完系统，未配置任何环境，先安装 <strong>git</strong>、<strong>nodejs</strong> 环境。</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-jxq298lkyyxkt9"></i><span>bash</span><div class="collapse show" id="collapse-jxq298lkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 配置git信息</span><br>git config --global user.name yourname<br>git config --global user.email youremail<br><span class="hljs-comment">## 如果已经有公钥，将公钥上传到github，若无，重新创建</span><br>ssh-keygen -t rsa -C youremail<br><span class="hljs-comment">## 安装完nodejs环境后,安装hexo命令</span><br>npm install hexo-cli -g<br></code></pre></td></tr></table></div></figure><p>克隆远程仓库，注意，拉取 <strong>source</strong> 分支即可</p><p><code>git clone -b source 仓库名称</code></p><p>进入该仓库目录，安装依赖：</p><p><code>npm install</code></p><p>至此博客恢复部署完成，可以在本地尝试一下，看是否正常运行:</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-b1fcmjlkyyxkt9"></i><span>bash</span><div class="collapse show" id="collapse-b1fcmjlkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo c // 删除public文件夹<br>hexo g // 在hexo站点根目录下生成public文件夹<br>hexo s // 本地启动服务<br>hexo d // 部署站点，在本地生成.deploy_git文件夹，并将编译后的文件上传至 GitHub<br></code></pre></td></tr></table></div></figure><h2 id="小Tips"><a href="#小Tips" class="headerlink" title="小Tips"></a>小Tips</h2><p>每次手动部署推送还是挺麻烦的，使用python脚本一键部署：</p><figure class="highlight python"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-3qolu9lkyyxkt9"></i><span>python</span><div class="collapse show" id="collapse-3qolu9lkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">## 一键部署</span><br><span class="hljs-keyword">import</span> os<br>static_cmd=<span class="hljs-string">&quot;hexo c &amp;&amp; hexo g &amp;&amp; hexo d&quot;</span><br>source_cmd=<span class="hljs-string">&quot;git add . &amp;&amp; git commit -m &#x27;source update&#x27; &amp;&amp; git push origin source&quot;</span><br><span class="hljs-keyword">try</span>:<br>    os.system(static_cmd)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;网页push成功！&quot;</span>)<br>    os.system(source_cmd)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;源代码push成功！&quot;</span>)<br><span class="hljs-keyword">except</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;部署失败，请手动检查情况！&quot;</span>)<br></code></pre></td></tr></table></div></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>有时候出现测试git连接失败、或推送失败、部署失败，大概率是因为 <strong>代理</strong> 问题，关闭代理或参考以下方法重新部署：</p><figure class="highlight bash"><i class="iconfont icon-github-fill" type="button" data-toggle="collapse" data-target="#collapse-9outqvlkyyxkt9"></i><span>bash</span><div class="collapse show" id="collapse-9outqvlkyyxkt9"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">## 在clash规则里面添加的，用于22端口直连，因为ssh使用的是22端口</span><br>- DST-PORT,22,DIRECT <br><span class="hljs-comment">## 测试git连接</span><br>ssh -T git@github.com<br></code></pre></td></tr></table></div></figure>]]></content>
    
    
    <categories>
      
      <category>Hexo 博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
